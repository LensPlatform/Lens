// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/tables.proto

package user

import context "context"
import fmt "fmt"
import strings "strings"

import auth1 "github.com/infobloxopen/atlas-app-toolkit/auth"
import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import pq1 "github.com/lib/pq"

import math "math"
import _ "github.com/mwitkow/go-proto-validators"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type UserORM struct {
	AccountID            string
	Age                  int32
	Bio                  string
	BirthDate            string
	CreatedAt            string
	DeletedAt            string
	Email                string
	FirstName            string
	Gender               string
	Headline             string
	Id                   int32 `gorm:"type:integer;primary_key"`
	Intent               string
	Languages            string
	LastName             string
	Password             string
	PasswordConfirmed    string
	PhoneNumber          uint32
	Profile              *ProfileORM `gorm:"foreignkey:ProfileId;association_foreignkey:Id"`
	ProfileId            *int32
	ResetToken           string
	ResetTokenExpiration string
	UpdatedAt            string
	UserAccountType      int32
	UserName             string
}

// TableName overrides the default tablename generated by GORM
func (UserORM) TableName() string {
	return "users"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *User) ToORM(ctx context.Context) (UserORM, error) {
	to := UserORM{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	to.UserAccountType = int32(m.UserAccountType)
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.UserName = m.UserName
	to.Gender = m.Gender
	to.Languages = m.Languages
	to.Password = m.Password
	to.PasswordConfirmed = m.PasswordConfirmed
	to.Age = m.Age
	to.BirthDate = m.BirthDate
	to.PhoneNumber = m.PhoneNumber
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.Intent = m.Intent
	to.Email = m.Email
	if m.Profile != nil {
		tempProfile, err := m.Profile.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Profile = &tempProfile
	}
	to.DeletedAt = m.DeletedAt
	to.ResetToken = m.ResetToken
	to.ResetTokenExpiration = m.ResetTokenExpiration
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(UserWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserORM) ToPB(ctx context.Context) (User, error) {
	to := User{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	to.UserAccountType = AccountType(m.UserAccountType)
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.UserName = m.UserName
	to.Gender = m.Gender
	to.Languages = m.Languages
	to.Password = m.Password
	to.PasswordConfirmed = m.PasswordConfirmed
	to.Age = m.Age
	to.BirthDate = m.BirthDate
	to.PhoneNumber = m.PhoneNumber
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.Intent = m.Intent
	to.Email = m.Email
	if m.Profile != nil {
		tempProfile, err := m.Profile.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Profile = &tempProfile
	}
	to.DeletedAt = m.DeletedAt
	to.ResetToken = m.ResetToken
	to.ResetTokenExpiration = m.ResetTokenExpiration
	if posthook, ok := interface{}(m).(UserWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type User the arg will be the target, the caller the one being converted from

// UserBeforeToORM called before default ToORM code
type UserWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserORM) error
}

// UserAfterToORM called after default ToORM code
type UserWithAfterToORM interface {
	AfterToORM(context.Context, *UserORM) error
}

// UserBeforeToPB called before default ToPB code
type UserWithBeforeToPB interface {
	BeforeToPB(context.Context, *User) error
}

// UserAfterToPB called after default ToPB code
type UserWithAfterToPB interface {
	AfterToPB(context.Context, *User) error
}

type ProfileORM struct {
	Address                  *AddressORM `gorm:"foreignkey:AddressProfileId;association_foreignkey:Id"`
	CreatedAt                string
	DeletedAt                string
	Education                []*EducationORM  `gorm:"foreignkey:ProfileId;association_foreignkey:Id"`
	Experience               []*ExperienceORM `gorm:"foreignkey:ProfileId;association_foreignkey:Id"`
	FundingId                *int32
	GroupId                  *int32
	Id                       int32                      `gorm:"type:integer;primary_key"`
	InvestmentDetails        *InvestorFundingDetailsORM `gorm:"foreignkey:InvestorFundingDetailsId;association_foreignkey:Id"`
	InvestorFundingDetailsId *uint32
	Languages                pq1.StringArray `gorm:"type:text[]"`
	PlacesLivedIn            []*AddressORM   `gorm:"foreignkey:PlacesLivedInProfileId;association_foreignkey:Id"`
	ProfileType              int32
	Settings                 *SettingsORM `gorm:"foreignkey:SettingsId;association_foreignkey:Id"`
	SettingsId               *int32
	Subscription             []*SubscriptionsORM `gorm:"foreignkey:ProfileId;association_foreignkey:Id"`
	Title                    string
	UpdatedAt                string
	UserGroups               []*GroupORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:profile_groups;jointable_foreignkey:profile_id;association_jointable_foreignkey:group_id"`
	UserTeams                []*TeamORM  `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:profile_teams;jointable_foreignkey:profile_id;association_jointable_foreignkey:team_id"`
}

// TableName overrides the default tablename generated by GORM
func (ProfileORM) TableName() string {
	return "profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Profile) ToORM(ctx context.Context) (ProfileORM, error) {
	to := ProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(ProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	to.Title = m.Title
	for _, v := range m.Experience {
		if v != nil {
			if tempExperience, cErr := v.ToORM(ctx); cErr == nil {
				to.Experience = append(to.Experience, &tempExperience)
			} else {
				return to, cErr
			}
		} else {
			to.Experience = append(to.Experience, nil)
		}
	}
	if m.Address != nil {
		tempAddress, err := m.Address.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	for _, v := range m.Education {
		if v != nil {
			if tempEducation, cErr := v.ToORM(ctx); cErr == nil {
				to.Education = append(to.Education, &tempEducation)
			} else {
				return to, cErr
			}
		} else {
			to.Education = append(to.Education, nil)
		}
	}
	// Repeated type []*Skill is not an ORMable message type
	for _, v := range m.UserTeams {
		if v != nil {
			if tempUserTeams, cErr := v.ToORM(ctx); cErr == nil {
				to.UserTeams = append(to.UserTeams, &tempUserTeams)
			} else {
				return to, cErr
			}
		} else {
			to.UserTeams = append(to.UserTeams, nil)
		}
	}
	for _, v := range m.UserGroups {
		if v != nil {
			if tempUserGroups, cErr := v.ToORM(ctx); cErr == nil {
				to.UserGroups = append(to.UserGroups, &tempUserGroups)
			} else {
				return to, cErr
			}
		} else {
			to.UserGroups = append(to.UserGroups, nil)
		}
	}
	if m.Settings != nil {
		tempSettings, err := m.Settings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Settings = &tempSettings
	}
	for _, v := range m.Subscription {
		if v != nil {
			if tempSubscription, cErr := v.ToORM(ctx); cErr == nil {
				to.Subscription = append(to.Subscription, &tempSubscription)
			} else {
				return to, cErr
			}
		} else {
			to.Subscription = append(to.Subscription, nil)
		}
	}
	if m.InvestmentDetails != nil {
		tempInvestmentDetails, err := m.InvestmentDetails.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.InvestmentDetails = &tempInvestmentDetails
	}
	to.ProfileType = int32(m.ProfileType)
	for _, v := range m.PlacesLivedIn {
		if v != nil {
			if tempPlacesLivedIn, cErr := v.ToORM(ctx); cErr == nil {
				to.PlacesLivedIn = append(to.PlacesLivedIn, &tempPlacesLivedIn)
			} else {
				return to, cErr
			}
		} else {
			to.PlacesLivedIn = append(to.PlacesLivedIn, nil)
		}
	}
	if m.Languages != nil {
		to.Languages = make(pq1.StringArray, len(m.Languages))
		copy(to.Languages, m.Languages)
	}
	to.DeletedAt = m.DeletedAt
	if posthook, ok := interface{}(m).(ProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ProfileORM) ToPB(ctx context.Context) (Profile, error) {
	to := Profile{}
	var err error
	if prehook, ok := interface{}(m).(ProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	to.Title = m.Title
	for _, v := range m.Experience {
		if v != nil {
			if tempExperience, cErr := v.ToPB(ctx); cErr == nil {
				to.Experience = append(to.Experience, &tempExperience)
			} else {
				return to, cErr
			}
		} else {
			to.Experience = append(to.Experience, nil)
		}
	}
	if m.Address != nil {
		tempAddress, err := m.Address.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	for _, v := range m.Education {
		if v != nil {
			if tempEducation, cErr := v.ToPB(ctx); cErr == nil {
				to.Education = append(to.Education, &tempEducation)
			} else {
				return to, cErr
			}
		} else {
			to.Education = append(to.Education, nil)
		}
	}
	// Repeated type []*Skill is not an ORMable message type
	for _, v := range m.UserTeams {
		if v != nil {
			if tempUserTeams, cErr := v.ToPB(ctx); cErr == nil {
				to.UserTeams = append(to.UserTeams, &tempUserTeams)
			} else {
				return to, cErr
			}
		} else {
			to.UserTeams = append(to.UserTeams, nil)
		}
	}
	for _, v := range m.UserGroups {
		if v != nil {
			if tempUserGroups, cErr := v.ToPB(ctx); cErr == nil {
				to.UserGroups = append(to.UserGroups, &tempUserGroups)
			} else {
				return to, cErr
			}
		} else {
			to.UserGroups = append(to.UserGroups, nil)
		}
	}
	if m.Settings != nil {
		tempSettings, err := m.Settings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Settings = &tempSettings
	}
	for _, v := range m.Subscription {
		if v != nil {
			if tempSubscription, cErr := v.ToPB(ctx); cErr == nil {
				to.Subscription = append(to.Subscription, &tempSubscription)
			} else {
				return to, cErr
			}
		} else {
			to.Subscription = append(to.Subscription, nil)
		}
	}
	if m.InvestmentDetails != nil {
		tempInvestmentDetails, err := m.InvestmentDetails.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.InvestmentDetails = &tempInvestmentDetails
	}
	to.ProfileType = AccountType(m.ProfileType)
	for _, v := range m.PlacesLivedIn {
		if v != nil {
			if tempPlacesLivedIn, cErr := v.ToPB(ctx); cErr == nil {
				to.PlacesLivedIn = append(to.PlacesLivedIn, &tempPlacesLivedIn)
			} else {
				return to, cErr
			}
		} else {
			to.PlacesLivedIn = append(to.PlacesLivedIn, nil)
		}
	}
	if m.Languages != nil {
		to.Languages = make(pq1.StringArray, len(m.Languages))
		copy(to.Languages, m.Languages)
	}
	to.DeletedAt = m.DeletedAt
	if posthook, ok := interface{}(m).(ProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Profile the arg will be the target, the caller the one being converted from

// ProfileBeforeToORM called before default ToORM code
type ProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *ProfileORM) error
}

// ProfileAfterToORM called after default ToORM code
type ProfileWithAfterToORM interface {
	AfterToORM(context.Context, *ProfileORM) error
}

// ProfileBeforeToPB called before default ToPB code
type ProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *Profile) error
}

// ProfileAfterToPB called after default ToPB code
type ProfileWithAfterToPB interface {
	AfterToPB(context.Context, *Profile) error
}

type GroupORM struct {
	CreatedAt            string
	DeletedAt            string
	GroupBio             string
	GroupMembers         []*ProfileORM `gorm:"foreignkey:GroupId;association_foreignkey:Id"`
	GroupName            string
	GroupType            int32
	Id                   int32 `gorm:"type:integer;primary_key"`
	NumberOfGroupMembers int32
	Tags                 pq1.StringArray `gorm:"type:text[]"`
	Type                 string
	UpdatedtAt           string
}

// TableName overrides the default tablename generated by GORM
func (GroupORM) TableName() string {
	return "groups"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Group) ToORM(ctx context.Context) (GroupORM, error) {
	to := GroupORM{}
	var err error
	if prehook, ok := interface{}(m).(GroupWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedAt = m.CreatedAt
	to.UpdatedtAt = m.UpdatedtAt
	to.Type = m.Type
	to.GroupName = m.GroupName
	to.GroupBio = m.GroupBio
	if m.Tags != nil {
		to.Tags = make(pq1.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	to.NumberOfGroupMembers = m.NumberOfGroupMembers
	for _, v := range m.GroupMembers {
		if v != nil {
			if tempGroupMembers, cErr := v.ToORM(ctx); cErr == nil {
				to.GroupMembers = append(to.GroupMembers, &tempGroupMembers)
			} else {
				return to, cErr
			}
		} else {
			to.GroupMembers = append(to.GroupMembers, nil)
		}
	}
	to.GroupType = int32(m.GroupType)
	to.DeletedAt = m.DeletedAt
	if posthook, ok := interface{}(m).(GroupWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *GroupORM) ToPB(ctx context.Context) (Group, error) {
	to := Group{}
	var err error
	if prehook, ok := interface{}(m).(GroupWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedAt = m.CreatedAt
	to.UpdatedtAt = m.UpdatedtAt
	to.Type = m.Type
	to.GroupName = m.GroupName
	to.GroupBio = m.GroupBio
	if m.Tags != nil {
		to.Tags = make(pq1.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	to.NumberOfGroupMembers = m.NumberOfGroupMembers
	for _, v := range m.GroupMembers {
		if v != nil {
			if tempGroupMembers, cErr := v.ToPB(ctx); cErr == nil {
				to.GroupMembers = append(to.GroupMembers, &tempGroupMembers)
			} else {
				return to, cErr
			}
		} else {
			to.GroupMembers = append(to.GroupMembers, nil)
		}
	}
	to.GroupType = AccountType(m.GroupType)
	to.DeletedAt = m.DeletedAt
	if posthook, ok := interface{}(m).(GroupWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Group the arg will be the target, the caller the one being converted from

// GroupBeforeToORM called before default ToORM code
type GroupWithBeforeToORM interface {
	BeforeToORM(context.Context, *GroupORM) error
}

// GroupAfterToORM called after default ToORM code
type GroupWithAfterToORM interface {
	AfterToORM(context.Context, *GroupORM) error
}

// GroupBeforeToPB called before default ToPB code
type GroupWithBeforeToPB interface {
	BeforeToPB(context.Context, *Group) error
}

// GroupAfterToPB called after default ToPB code
type GroupWithAfterToPB interface {
	AfterToPB(context.Context, *Group) error
}

type TeamORM struct {
	Advisors           []*ProfileORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:team_advisors;jointable_foreignkey:team_id;association_jointable_foreignkey:profile_id"`
	CreatedAt          string
	DeletedAt          string
	FoundedDate        string
	GroupType          int32
	Headquarters       *AddressORM `gorm:"foreignkey:TeamId;association_foreignkey:Id"`
	Id                 int32       `gorm:"type:integer;primary_key"`
	IndustryOfInterest string
	InvestorDetails    *InvestorFundingDetailsORM `gorm:"foreignkey:TeamId;association_foreignkey:Id"`
	NumberOfEmployees  int32
	StartupDetails     *StartupFundingDetailsORM `gorm:"foreignkey:TeamId;association_foreignkey:Id"`
	Subscriptions      []*SubscriptionsORM       `gorm:"foreignkey:TeamId;association_foreignkey:Id"`
	Tags               pq1.StringArray           `gorm:"type:text[]"`
	TeamBio            string
	TeamEmail          string
	TeamMembers        []*ProfileORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:team_team_members;jointable_foreignkey:team_id;association_jointable_foreignkey:profile_id"`
	TeamName           string
	Type               string
	UpdatedtAt         string
}

// TableName overrides the default tablename generated by GORM
func (TeamORM) TableName() string {
	return "teams"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Team) ToORM(ctx context.Context) (TeamORM, error) {
	to := TeamORM{}
	var err error
	if prehook, ok := interface{}(m).(TeamWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedAt = m.CreatedAt
	to.UpdatedtAt = m.UpdatedtAt
	to.TeamName = m.TeamName
	if m.Tags != nil {
		to.Tags = make(pq1.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	to.TeamEmail = m.TeamEmail
	to.Type = m.Type
	to.TeamBio = m.TeamBio
	to.IndustryOfInterest = m.IndustryOfInterest
	to.FoundedDate = m.FoundedDate
	to.NumberOfEmployees = m.NumberOfEmployees
	if m.Headquarters != nil {
		tempHeadquarters, err := m.Headquarters.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Headquarters = &tempHeadquarters
	}
	for _, v := range m.TeamMembers {
		if v != nil {
			if tempTeamMembers, cErr := v.ToORM(ctx); cErr == nil {
				to.TeamMembers = append(to.TeamMembers, &tempTeamMembers)
			} else {
				return to, cErr
			}
		} else {
			to.TeamMembers = append(to.TeamMembers, nil)
		}
	}
	for _, v := range m.Advisors {
		if v != nil {
			if tempAdvisors, cErr := v.ToORM(ctx); cErr == nil {
				to.Advisors = append(to.Advisors, &tempAdvisors)
			} else {
				return to, cErr
			}
		} else {
			to.Advisors = append(to.Advisors, nil)
		}
	}
	if m.InvestorDetails != nil {
		tempInvestorDetails, err := m.InvestorDetails.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.InvestorDetails = &tempInvestorDetails
	}
	if m.StartupDetails != nil {
		tempStartupDetails, err := m.StartupDetails.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.StartupDetails = &tempStartupDetails
	}
	to.GroupType = int32(m.GroupType)
	to.DeletedAt = m.DeletedAt
	for _, v := range m.Subscriptions {
		if v != nil {
			if tempSubscriptions, cErr := v.ToORM(ctx); cErr == nil {
				to.Subscriptions = append(to.Subscriptions, &tempSubscriptions)
			} else {
				return to, cErr
			}
		} else {
			to.Subscriptions = append(to.Subscriptions, nil)
		}
	}
	if posthook, ok := interface{}(m).(TeamWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TeamORM) ToPB(ctx context.Context) (Team, error) {
	to := Team{}
	var err error
	if prehook, ok := interface{}(m).(TeamWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedAt = m.CreatedAt
	to.UpdatedtAt = m.UpdatedtAt
	to.TeamName = m.TeamName
	if m.Tags != nil {
		to.Tags = make(pq1.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	to.TeamEmail = m.TeamEmail
	to.Type = m.Type
	to.TeamBio = m.TeamBio
	to.IndustryOfInterest = m.IndustryOfInterest
	to.FoundedDate = m.FoundedDate
	to.NumberOfEmployees = m.NumberOfEmployees
	if m.Headquarters != nil {
		tempHeadquarters, err := m.Headquarters.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Headquarters = &tempHeadquarters
	}
	for _, v := range m.TeamMembers {
		if v != nil {
			if tempTeamMembers, cErr := v.ToPB(ctx); cErr == nil {
				to.TeamMembers = append(to.TeamMembers, &tempTeamMembers)
			} else {
				return to, cErr
			}
		} else {
			to.TeamMembers = append(to.TeamMembers, nil)
		}
	}
	for _, v := range m.Advisors {
		if v != nil {
			if tempAdvisors, cErr := v.ToPB(ctx); cErr == nil {
				to.Advisors = append(to.Advisors, &tempAdvisors)
			} else {
				return to, cErr
			}
		} else {
			to.Advisors = append(to.Advisors, nil)
		}
	}
	if m.InvestorDetails != nil {
		tempInvestorDetails, err := m.InvestorDetails.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.InvestorDetails = &tempInvestorDetails
	}
	if m.StartupDetails != nil {
		tempStartupDetails, err := m.StartupDetails.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.StartupDetails = &tempStartupDetails
	}
	to.GroupType = AccountType(m.GroupType)
	to.DeletedAt = m.DeletedAt
	for _, v := range m.Subscriptions {
		if v != nil {
			if tempSubscriptions, cErr := v.ToPB(ctx); cErr == nil {
				to.Subscriptions = append(to.Subscriptions, &tempSubscriptions)
			} else {
				return to, cErr
			}
		} else {
			to.Subscriptions = append(to.Subscriptions, nil)
		}
	}
	if posthook, ok := interface{}(m).(TeamWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Team the arg will be the target, the caller the one being converted from

// TeamBeforeToORM called before default ToORM code
type TeamWithBeforeToORM interface {
	BeforeToORM(context.Context, *TeamORM) error
}

// TeamAfterToORM called after default ToORM code
type TeamWithAfterToORM interface {
	AfterToORM(context.Context, *TeamORM) error
}

// TeamBeforeToPB called before default ToPB code
type TeamWithBeforeToPB interface {
	BeforeToPB(context.Context, *Team) error
}

// TeamAfterToPB called after default ToPB code
type TeamWithAfterToPB interface {
	AfterToPB(context.Context, *Team) error
}

type InvestorFundingDetailsORM struct {
	CreatedAt           string
	Id                  uint32 `gorm:"type:integer;primary_key"`
	InvestmentStage     int32
	Investments         []*InvestmentORM `gorm:"foreignkey:InvestorFundingDetailsId;association_foreignkey:Id"`
	InvestorType        int32
	NumberOfExits       int32
	NumberOfFunds       int32
	NumberOfinvestments int32
	TeamId              *int32
	UpdatedAt           string
}

// TableName overrides the default tablename generated by GORM
func (InvestorFundingDetailsORM) TableName() string {
	return "investor_funding_details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *InvestorFundingDetails) ToORM(ctx context.Context) (InvestorFundingDetailsORM, error) {
	to := InvestorFundingDetailsORM{}
	var err error
	if prehook, ok := interface{}(m).(InvestorFundingDetailsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	to.InvestorType = int32(m.InvestorType)
	to.InvestmentStage = int32(m.InvestmentStage)
	to.NumberOfExits = m.NumberOfExits
	to.NumberOfinvestments = m.NumberOfinvestments
	to.NumberOfFunds = m.NumberOfFunds
	for _, v := range m.Investments {
		if v != nil {
			if tempInvestments, cErr := v.ToORM(ctx); cErr == nil {
				to.Investments = append(to.Investments, &tempInvestments)
			} else {
				return to, cErr
			}
		} else {
			to.Investments = append(to.Investments, nil)
		}
	}
	if posthook, ok := interface{}(m).(InvestorFundingDetailsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvestorFundingDetailsORM) ToPB(ctx context.Context) (InvestorFundingDetails, error) {
	to := InvestorFundingDetails{}
	var err error
	if prehook, ok := interface{}(m).(InvestorFundingDetailsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	to.InvestorType = InvestorType(m.InvestorType)
	to.InvestmentStage = InvestmentStage(m.InvestmentStage)
	to.NumberOfExits = m.NumberOfExits
	to.NumberOfinvestments = m.NumberOfinvestments
	to.NumberOfFunds = m.NumberOfFunds
	for _, v := range m.Investments {
		if v != nil {
			if tempInvestments, cErr := v.ToPB(ctx); cErr == nil {
				to.Investments = append(to.Investments, &tempInvestments)
			} else {
				return to, cErr
			}
		} else {
			to.Investments = append(to.Investments, nil)
		}
	}
	if posthook, ok := interface{}(m).(InvestorFundingDetailsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type InvestorFundingDetails the arg will be the target, the caller the one being converted from

// InvestorFundingDetailsBeforeToORM called before default ToORM code
type InvestorFundingDetailsWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvestorFundingDetailsORM) error
}

// InvestorFundingDetailsAfterToORM called after default ToORM code
type InvestorFundingDetailsWithAfterToORM interface {
	AfterToORM(context.Context, *InvestorFundingDetailsORM) error
}

// InvestorFundingDetailsBeforeToPB called before default ToPB code
type InvestorFundingDetailsWithBeforeToPB interface {
	BeforeToPB(context.Context, *InvestorFundingDetails) error
}

// InvestorFundingDetailsAfterToPB called after default ToPB code
type InvestorFundingDetailsWithAfterToPB interface {
	AfterToPB(context.Context, *InvestorFundingDetails) error
}

type StartupFundingDetailsORM struct {
	CompanyDetails *DetailsORM `gorm:"foreignkey:StartupFundingDetailsId;association_foreignkey:Id"`
	CreatedAt      string
	Funding        *FundingORM `gorm:"foreignkey:StartupFundingDetailsId;association_foreignkey:Id"`
	Id             uint32      `gorm:"type:integer;primary_key"`
	TeamId         *int32
	UpdatedAt      string
}

// TableName overrides the default tablename generated by GORM
func (StartupFundingDetailsORM) TableName() string {
	return "startup_funding_details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *StartupFundingDetails) ToORM(ctx context.Context) (StartupFundingDetailsORM, error) {
	to := StartupFundingDetailsORM{}
	var err error
	if prehook, ok := interface{}(m).(StartupFundingDetailsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	if m.Funding != nil {
		tempFunding, err := m.Funding.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Funding = &tempFunding
	}
	if m.CompanyDetails != nil {
		tempCompanyDetails, err := m.CompanyDetails.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.CompanyDetails = &tempCompanyDetails
	}
	if posthook, ok := interface{}(m).(StartupFundingDetailsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *StartupFundingDetailsORM) ToPB(ctx context.Context) (StartupFundingDetails, error) {
	to := StartupFundingDetails{}
	var err error
	if prehook, ok := interface{}(m).(StartupFundingDetailsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.CreatedAt = m.CreatedAt
	to.UpdatedAt = m.UpdatedAt
	if m.Funding != nil {
		tempFunding, err := m.Funding.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Funding = &tempFunding
	}
	if m.CompanyDetails != nil {
		tempCompanyDetails, err := m.CompanyDetails.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.CompanyDetails = &tempCompanyDetails
	}
	if posthook, ok := interface{}(m).(StartupFundingDetailsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type StartupFundingDetails the arg will be the target, the caller the one being converted from

// StartupFundingDetailsBeforeToORM called before default ToORM code
type StartupFundingDetailsWithBeforeToORM interface {
	BeforeToORM(context.Context, *StartupFundingDetailsORM) error
}

// StartupFundingDetailsAfterToORM called after default ToORM code
type StartupFundingDetailsWithAfterToORM interface {
	AfterToORM(context.Context, *StartupFundingDetailsORM) error
}

// StartupFundingDetailsBeforeToPB called before default ToPB code
type StartupFundingDetailsWithBeforeToPB interface {
	BeforeToPB(context.Context, *StartupFundingDetails) error
}

// StartupFundingDetailsAfterToPB called after default ToPB code
type StartupFundingDetailsWithAfterToPB interface {
	AfterToPB(context.Context, *StartupFundingDetails) error
}

type FundingORM struct {
	Id                      int32 `gorm:"type:integer;primary_key"`
	InvestmentStage         string
	InvestorType            string
	Investors               []*ProfileORM `gorm:"foreignkey:FundingId;association_foreignkey:Id"`
	LatestRound             string
	LatestRoundDate         string
	LatestRoundFunding      int32
	StartupFundingDetailsId *uint32
	TotalFunding            int32
}

// TableName overrides the default tablename generated by GORM
func (FundingORM) TableName() string {
	return "fundings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Funding) ToORM(ctx context.Context) (FundingORM, error) {
	to := FundingORM{}
	var err error
	if prehook, ok := interface{}(m).(FundingWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TotalFunding = m.TotalFunding
	to.LatestRound = m.LatestRound
	to.LatestRoundDate = m.LatestRoundDate
	to.LatestRoundFunding = m.LatestRoundFunding
	for _, v := range m.Investors {
		if v != nil {
			if tempInvestors, cErr := v.ToORM(ctx); cErr == nil {
				to.Investors = append(to.Investors, &tempInvestors)
			} else {
				return to, cErr
			}
		} else {
			to.Investors = append(to.Investors, nil)
		}
	}
	to.InvestorType = m.InvestorType
	to.InvestmentStage = m.InvestmentStage
	if posthook, ok := interface{}(m).(FundingWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FundingORM) ToPB(ctx context.Context) (Funding, error) {
	to := Funding{}
	var err error
	if prehook, ok := interface{}(m).(FundingWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TotalFunding = m.TotalFunding
	to.LatestRound = m.LatestRound
	to.LatestRoundDate = m.LatestRoundDate
	to.LatestRoundFunding = m.LatestRoundFunding
	for _, v := range m.Investors {
		if v != nil {
			if tempInvestors, cErr := v.ToPB(ctx); cErr == nil {
				to.Investors = append(to.Investors, &tempInvestors)
			} else {
				return to, cErr
			}
		} else {
			to.Investors = append(to.Investors, nil)
		}
	}
	to.InvestorType = m.InvestorType
	to.InvestmentStage = m.InvestmentStage
	if posthook, ok := interface{}(m).(FundingWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Funding the arg will be the target, the caller the one being converted from

// FundingBeforeToORM called before default ToORM code
type FundingWithBeforeToORM interface {
	BeforeToORM(context.Context, *FundingORM) error
}

// FundingAfterToORM called after default ToORM code
type FundingWithAfterToORM interface {
	AfterToORM(context.Context, *FundingORM) error
}

// FundingBeforeToPB called before default ToPB code
type FundingWithBeforeToPB interface {
	BeforeToPB(context.Context, *Funding) error
}

// FundingAfterToPB called after default ToPB code
type FundingWithAfterToPB interface {
	AfterToPB(context.Context, *Funding) error
}

// DefaultCreateUser executes a basic gorm create call
func DefaultCreateUser(ctx context.Context, in *User, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadUser executes a basic gorm read call
func DefaultReadUser(ctx context.Context, in *User, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &UserORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteUser(ctx context.Context, in *User, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteUserSet(ctx context.Context, in []*User, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*User, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*User, *gorm1.DB) error
}

// DefaultStrictUpdateUser clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUser(ctx context.Context, in *User, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &UserORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchUser executes a basic gorm update call with patch behavior
func DefaultPatchUser(ctx context.Context, in *User, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj User
	var err error
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUser(ctx, &User{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUser(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUser(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetUser executes a bulk gorm update call with patch behavior
func DefaultPatchSetUser(ctx context.Context, objects []*User, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*User, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*User, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUser(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUser patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUser(ctx context.Context, patchee *User, patcher *User, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*User, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedProfile bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UserAccountType" {
			patchee.UserAccountType = patcher.UserAccountType
			continue
		}
		if f == prefix+"FirstName" {
			patchee.FirstName = patcher.FirstName
			continue
		}
		if f == prefix+"LastName" {
			patchee.LastName = patcher.LastName
			continue
		}
		if f == prefix+"UserName" {
			patchee.UserName = patcher.UserName
			continue
		}
		if f == prefix+"Gender" {
			patchee.Gender = patcher.Gender
			continue
		}
		if f == prefix+"Languages" {
			patchee.Languages = patcher.Languages
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
		if f == prefix+"PasswordConfirmed" {
			patchee.PasswordConfirmed = patcher.PasswordConfirmed
			continue
		}
		if f == prefix+"Age" {
			patchee.Age = patcher.Age
			continue
		}
		if f == prefix+"BirthDate" {
			patchee.BirthDate = patcher.BirthDate
			continue
		}
		if f == prefix+"PhoneNumber" {
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if f == prefix+"Bio" {
			patchee.Bio = patcher.Bio
			continue
		}
		if f == prefix+"Headline" {
			patchee.Headline = patcher.Headline
			continue
		}
		if f == prefix+"Intent" {
			patchee.Intent = patcher.Intent
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if !updatedProfile && strings.HasPrefix(f, prefix+"Profile.") {
			updatedProfile = true
			if patcher.Profile == nil {
				patchee.Profile = nil
				continue
			}
			if patchee.Profile == nil {
				patchee.Profile = &Profile{}
			}
			if o, err := DefaultApplyFieldMaskProfile(ctx, patchee.Profile, patcher.Profile, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Profile.", db); err != nil {
				return nil, err
			} else {
				patchee.Profile = o
			}
			continue
		}
		if f == prefix+"Profile" {
			updatedProfile = true
			patchee.Profile = patcher.Profile
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"ResetToken" {
			patchee.ResetToken = patcher.ResetToken
			continue
		}
		if f == prefix+"ResetTokenExpiration" {
			patchee.ResetTokenExpiration = patcher.ResetTokenExpiration
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUser executes a gorm list call
func DefaultListUser(ctx context.Context, db *gorm1.DB) ([]*User, error) {
	in := User{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &UserORM{}, &User{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*User{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]UserORM) error
}

// DefaultCreateProfile executes a basic gorm create call
func DefaultCreateProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadProfile executes a basic gorm read call
func DefaultReadProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ProfileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ProfileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ProfileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ProfileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteProfile(ctx context.Context, in *Profile, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ProfileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteProfileSet(ctx context.Context, in []*Profile, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ProfileORM{})).(ProfileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ProfileORM{})).(ProfileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ProfileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Profile, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Profile, *gorm1.DB) error
}

// DefaultStrictUpdateProfile clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ProfileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAddress := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterAddress.AddressProfileId = new(int32)
	*filterAddress.AddressProfileId = ormObj.Id
	if err = db.Where(filterAddress).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterEducation := EducationORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterEducation.ProfileId = new(int32)
	*filterEducation.ProfileId = ormObj.Id
	if err = db.Where(filterEducation).Delete(EducationORM{}).Error; err != nil {
		return nil, err
	}
	filterExperience := ExperienceORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterExperience.ProfileId = new(int32)
	*filterExperience.ProfileId = ormObj.Id
	if err = db.Where(filterExperience).Delete(ExperienceORM{}).Error; err != nil {
		return nil, err
	}
	filterPlacesLivedIn := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterPlacesLivedIn.PlacesLivedInProfileId = new(int32)
	*filterPlacesLivedIn.PlacesLivedInProfileId = ormObj.Id
	if err = db.Where(filterPlacesLivedIn).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterSubscription := SubscriptionsORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterSubscription.ProfileId = new(int32)
	*filterSubscription.ProfileId = ormObj.Id
	if err = db.Where(filterSubscription).Delete(SubscriptionsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ProfileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchProfile executes a basic gorm update call with patch behavior
func DefaultPatchProfile(ctx context.Context, in *Profile, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Profile
	var err error
	if hook, ok := interface{}(&pbObj).(ProfileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadProfile(ctx, &Profile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ProfileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskProfile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ProfileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateProfile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ProfileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ProfileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetProfile executes a bulk gorm update call with patch behavior
func DefaultPatchSetProfile(ctx context.Context, objects []*Profile, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Profile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Profile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchProfile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskProfile(ctx context.Context, patchee *Profile, patcher *Profile, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Profile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedAddress bool
	var updatedSocialMedia bool
	var updatedContact bool
	var updatedSettings bool
	var updatedInvestmentDetails bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Title" {
			patchee.Title = patcher.Title
			continue
		}
		if f == prefix+"Experience" {
			patchee.Experience = patcher.Experience
			continue
		}
		if !updatedAddress && strings.HasPrefix(f, prefix+"Address.") {
			updatedAddress = true
			if patcher.Address == nil {
				patchee.Address = nil
				continue
			}
			if patchee.Address == nil {
				patchee.Address = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.Address, patcher.Address, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Address.", db); err != nil {
				return nil, err
			} else {
				patchee.Address = o
			}
			continue
		}
		if f == prefix+"Address" {
			updatedAddress = true
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Education" {
			patchee.Education = patcher.Education
			continue
		}
		if f == prefix+"Skills" {
			patchee.Skills = patcher.Skills
			continue
		}
		if f == prefix+"UserTeams" {
			patchee.UserTeams = patcher.UserTeams
			continue
		}
		if f == prefix+"UserGroups" {
			patchee.UserGroups = patcher.UserGroups
			continue
		}
		if !updatedSocialMedia && strings.HasPrefix(f, prefix+"SocialMedia.") {
			if patcher.SocialMedia == nil {
				patchee.SocialMedia = nil
				continue
			}
			if patchee.SocialMedia == nil {
				patchee.SocialMedia = &SocialMedia{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"SocialMedia."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.SocialMedia, patchee.SocialMedia, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"SocialMedia" {
			updatedSocialMedia = true
			patchee.SocialMedia = patcher.SocialMedia
			continue
		}
		if !updatedContact && strings.HasPrefix(f, prefix+"Contact.") {
			if patcher.Contact == nil {
				patchee.Contact = nil
				continue
			}
			if patchee.Contact == nil {
				patchee.Contact = &Contact{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Contact."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.Contact, patchee.Contact, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Contact" {
			updatedContact = true
			patchee.Contact = patcher.Contact
			continue
		}
		if !updatedSettings && strings.HasPrefix(f, prefix+"Settings.") {
			updatedSettings = true
			if patcher.Settings == nil {
				patchee.Settings = nil
				continue
			}
			if patchee.Settings == nil {
				patchee.Settings = &Settings{}
			}
			if o, err := DefaultApplyFieldMaskSettings(ctx, patchee.Settings, patcher.Settings, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Settings.", db); err != nil {
				return nil, err
			} else {
				patchee.Settings = o
			}
			continue
		}
		if f == prefix+"Settings" {
			updatedSettings = true
			patchee.Settings = patcher.Settings
			continue
		}
		if f == prefix+"Subscription" {
			patchee.Subscription = patcher.Subscription
			continue
		}
		if !updatedInvestmentDetails && strings.HasPrefix(f, prefix+"InvestmentDetails.") {
			updatedInvestmentDetails = true
			if patcher.InvestmentDetails == nil {
				patchee.InvestmentDetails = nil
				continue
			}
			if patchee.InvestmentDetails == nil {
				patchee.InvestmentDetails = &InvestorFundingDetails{}
			}
			if o, err := DefaultApplyFieldMaskInvestorFundingDetails(ctx, patchee.InvestmentDetails, patcher.InvestmentDetails, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"InvestmentDetails.", db); err != nil {
				return nil, err
			} else {
				patchee.InvestmentDetails = o
			}
			continue
		}
		if f == prefix+"InvestmentDetails" {
			updatedInvestmentDetails = true
			patchee.InvestmentDetails = patcher.InvestmentDetails
			continue
		}
		if f == prefix+"ProfileType" {
			patchee.ProfileType = patcher.ProfileType
			continue
		}
		if f == prefix+"PlacesLivedIn" {
			patchee.PlacesLivedIn = patcher.PlacesLivedIn
			continue
		}
		if f == prefix+"Languages" {
			patchee.Languages = patcher.Languages
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListProfile executes a gorm list call
func DefaultListProfile(ctx context.Context, db *gorm1.DB) ([]*Profile, error) {
	in := Profile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ProfileORM{}, &Profile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Profile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ProfileORM) error
}

// DefaultCreateGroup executes a basic gorm create call
func DefaultCreateGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type GroupORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadGroup executes a basic gorm read call
func DefaultReadGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &GroupORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := GroupORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(GroupORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type GroupORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteGroup(ctx context.Context, in *Group, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&GroupORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type GroupORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteGroupSet(ctx context.Context, in []*Group, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&GroupORM{})).(GroupORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&GroupORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&GroupORM{})).(GroupORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type GroupORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Group, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Group, *gorm1.DB) error
}

// DefaultStrictUpdateGroup clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateGroup")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &GroupORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterGroupMembers := ProfileORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterGroupMembers.GroupId = new(int32)
	*filterGroupMembers.GroupId = ormObj.Id
	if err = db.Where(filterGroupMembers).Delete(ProfileORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type GroupORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchGroup executes a basic gorm update call with patch behavior
func DefaultPatchGroup(ctx context.Context, in *Group, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Group
	var err error
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadGroup(ctx, &Group{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskGroup(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateGroup(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(GroupWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type GroupWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type GroupWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type GroupWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type GroupWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetGroup executes a bulk gorm update call with patch behavior
func DefaultPatchSetGroup(ctx context.Context, objects []*Group, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Group, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Group, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchGroup(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskGroup patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskGroup(ctx context.Context, patchee *Group, patcher *Group, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Group, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedtAt" {
			patchee.UpdatedtAt = patcher.UpdatedtAt
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"GroupName" {
			patchee.GroupName = patcher.GroupName
			continue
		}
		if f == prefix+"GroupBio" {
			patchee.GroupBio = patcher.GroupBio
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"NumberOfGroupMembers" {
			patchee.NumberOfGroupMembers = patcher.NumberOfGroupMembers
			continue
		}
		if f == prefix+"GroupMembers" {
			patchee.GroupMembers = patcher.GroupMembers
			continue
		}
		if f == prefix+"GroupType" {
			patchee.GroupType = patcher.GroupType
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListGroup executes a gorm list call
func DefaultListGroup(ctx context.Context, db *gorm1.DB) ([]*Group, error) {
	in := Group{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &GroupORM{}, &Group{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []GroupORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Group{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type GroupORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]GroupORM) error
}

// DefaultCreateTeam executes a basic gorm create call
func DefaultCreateTeam(ctx context.Context, in *Team, db *gorm1.DB) (*Team, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TeamORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadTeam executes a basic gorm read call
func DefaultReadTeam(ctx context.Context, in *Team, db *gorm1.DB) (*Team, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &TeamORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TeamORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TeamORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TeamORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteTeam(ctx context.Context, in *Team, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TeamORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TeamORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteTeamSet(ctx context.Context, in []*Team, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TeamORM{})).(TeamORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TeamORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TeamORM{})).(TeamORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TeamORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Team, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Team, *gorm1.DB) error
}

// DefaultStrictUpdateTeam clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTeam(ctx context.Context, in *Team, db *gorm1.DB) (*Team, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTeam")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TeamORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterHeadquarters := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterHeadquarters.TeamId = new(int32)
	*filterHeadquarters.TeamId = ormObj.Id
	if err = db.Where(filterHeadquarters).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterInvestorDetails := InvestorFundingDetailsORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterInvestorDetails.TeamId = new(int32)
	*filterInvestorDetails.TeamId = ormObj.Id
	if err = db.Where(filterInvestorDetails).Delete(InvestorFundingDetailsORM{}).Error; err != nil {
		return nil, err
	}
	filterStartupDetails := StartupFundingDetailsORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterStartupDetails.TeamId = new(int32)
	*filterStartupDetails.TeamId = ormObj.Id
	if err = db.Where(filterStartupDetails).Delete(StartupFundingDetailsORM{}).Error; err != nil {
		return nil, err
	}
	filterSubscriptions := SubscriptionsORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterSubscriptions.TeamId = new(int32)
	*filterSubscriptions.TeamId = ormObj.Id
	if err = db.Where(filterSubscriptions).Delete(SubscriptionsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TeamORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchTeam executes a basic gorm update call with patch behavior
func DefaultPatchTeam(ctx context.Context, in *Team, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Team, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Team
	var err error
	if hook, ok := interface{}(&pbObj).(TeamWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTeam(ctx, &Team{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TeamWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTeam(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TeamWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTeam(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TeamWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TeamWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Team, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TeamWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Team, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TeamWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Team, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TeamWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Team, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetTeam executes a bulk gorm update call with patch behavior
func DefaultPatchSetTeam(ctx context.Context, objects []*Team, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Team, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Team, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTeam(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTeam patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTeam(ctx context.Context, patchee *Team, patcher *Team, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Team, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedHeadquarters bool
	var updatedSocialMedia bool
	var updatedContact bool
	var updatedPrivacySetting bool
	var updatedInvestorDetails bool
	var updatedStartupDetails bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedtAt" {
			patchee.UpdatedtAt = patcher.UpdatedtAt
			continue
		}
		if f == prefix+"TeamName" {
			patchee.TeamName = patcher.TeamName
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"TeamEmail" {
			patchee.TeamEmail = patcher.TeamEmail
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"TeamBio" {
			patchee.TeamBio = patcher.TeamBio
			continue
		}
		if f == prefix+"IndustryOfInterest" {
			patchee.IndustryOfInterest = patcher.IndustryOfInterest
			continue
		}
		if f == prefix+"FoundedDate" {
			patchee.FoundedDate = patcher.FoundedDate
			continue
		}
		if f == prefix+"NumberOfEmployees" {
			patchee.NumberOfEmployees = patcher.NumberOfEmployees
			continue
		}
		if !updatedHeadquarters && strings.HasPrefix(f, prefix+"Headquarters.") {
			updatedHeadquarters = true
			if patcher.Headquarters == nil {
				patchee.Headquarters = nil
				continue
			}
			if patchee.Headquarters == nil {
				patchee.Headquarters = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.Headquarters, patcher.Headquarters, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Headquarters.", db); err != nil {
				return nil, err
			} else {
				patchee.Headquarters = o
			}
			continue
		}
		if f == prefix+"Headquarters" {
			updatedHeadquarters = true
			patchee.Headquarters = patcher.Headquarters
			continue
		}
		if f == prefix+"TeamMembers" {
			patchee.TeamMembers = patcher.TeamMembers
			continue
		}
		if f == prefix+"Advisors" {
			patchee.Advisors = patcher.Advisors
			continue
		}
		if !updatedSocialMedia && strings.HasPrefix(f, prefix+"SocialMedia.") {
			if patcher.SocialMedia == nil {
				patchee.SocialMedia = nil
				continue
			}
			if patchee.SocialMedia == nil {
				patchee.SocialMedia = &SocialMedia{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"SocialMedia."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.SocialMedia, patchee.SocialMedia, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"SocialMedia" {
			updatedSocialMedia = true
			patchee.SocialMedia = patcher.SocialMedia
			continue
		}
		if !updatedContact && strings.HasPrefix(f, prefix+"Contact.") {
			if patcher.Contact == nil {
				patchee.Contact = nil
				continue
			}
			if patchee.Contact == nil {
				patchee.Contact = &Contact{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Contact."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.Contact, patchee.Contact, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Contact" {
			updatedContact = true
			patchee.Contact = patcher.Contact
			continue
		}
		if !updatedPrivacySetting && strings.HasPrefix(f, prefix+"PrivacySetting.") {
			if patcher.PrivacySetting == nil {
				patchee.PrivacySetting = nil
				continue
			}
			if patchee.PrivacySetting == nil {
				patchee.PrivacySetting = &Privacy{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"PrivacySetting."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.PrivacySetting, patchee.PrivacySetting, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"PrivacySetting" {
			updatedPrivacySetting = true
			patchee.PrivacySetting = patcher.PrivacySetting
			continue
		}
		if !updatedInvestorDetails && strings.HasPrefix(f, prefix+"InvestorDetails.") {
			updatedInvestorDetails = true
			if patcher.InvestorDetails == nil {
				patchee.InvestorDetails = nil
				continue
			}
			if patchee.InvestorDetails == nil {
				patchee.InvestorDetails = &InvestorFundingDetails{}
			}
			if o, err := DefaultApplyFieldMaskInvestorFundingDetails(ctx, patchee.InvestorDetails, patcher.InvestorDetails, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"InvestorDetails.", db); err != nil {
				return nil, err
			} else {
				patchee.InvestorDetails = o
			}
			continue
		}
		if f == prefix+"InvestorDetails" {
			updatedInvestorDetails = true
			patchee.InvestorDetails = patcher.InvestorDetails
			continue
		}
		if !updatedStartupDetails && strings.HasPrefix(f, prefix+"StartupDetails.") {
			updatedStartupDetails = true
			if patcher.StartupDetails == nil {
				patchee.StartupDetails = nil
				continue
			}
			if patchee.StartupDetails == nil {
				patchee.StartupDetails = &StartupFundingDetails{}
			}
			if o, err := DefaultApplyFieldMaskStartupFundingDetails(ctx, patchee.StartupDetails, patcher.StartupDetails, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"StartupDetails.", db); err != nil {
				return nil, err
			} else {
				patchee.StartupDetails = o
			}
			continue
		}
		if f == prefix+"StartupDetails" {
			updatedStartupDetails = true
			patchee.StartupDetails = patcher.StartupDetails
			continue
		}
		if f == prefix+"GroupType" {
			patchee.GroupType = patcher.GroupType
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"Subscriptions" {
			patchee.Subscriptions = patcher.Subscriptions
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTeam executes a gorm list call
func DefaultListTeam(ctx context.Context, db *gorm1.DB) ([]*Team, error) {
	in := Team{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &TeamORM{}, &Team{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TeamORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Team{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TeamORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]TeamORM) error
}

// DefaultCreateInvestorFundingDetails executes a basic gorm create call
func DefaultCreateInvestorFundingDetails(ctx context.Context, in *InvestorFundingDetails, db *gorm1.DB) (*InvestorFundingDetails, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorFundingDetailsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorFundingDetailsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvestorFundingDetailsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorFundingDetailsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadInvestorFundingDetails executes a basic gorm read call
func DefaultReadInvestorFundingDetails(ctx context.Context, in *InvestorFundingDetails, db *gorm1.DB) (*InvestorFundingDetails, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestorFundingDetailsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &InvestorFundingDetailsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorFundingDetailsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvestorFundingDetailsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvestorFundingDetailsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvestorFundingDetailsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorFundingDetailsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorFundingDetailsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteInvestorFundingDetails(ctx context.Context, in *InvestorFundingDetails, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestorFundingDetailsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvestorFundingDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvestorFundingDetailsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvestorFundingDetailsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorFundingDetailsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteInvestorFundingDetailsSet(ctx context.Context, in []*InvestorFundingDetails, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvestorFundingDetailsORM{})).(InvestorFundingDetailsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvestorFundingDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvestorFundingDetailsORM{})).(InvestorFundingDetailsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvestorFundingDetailsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*InvestorFundingDetails, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorFundingDetailsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*InvestorFundingDetails, *gorm1.DB) error
}

// DefaultStrictUpdateInvestorFundingDetails clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvestorFundingDetails(ctx context.Context, in *InvestorFundingDetails, db *gorm1.DB) (*InvestorFundingDetails, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvestorFundingDetails")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvestorFundingDetailsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvestorFundingDetailsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterInvestments := InvestmentORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterInvestments.InvestorFundingDetailsId = new(uint32)
	*filterInvestments.InvestorFundingDetailsId = ormObj.Id
	if err = db.Where(filterInvestments).Delete(InvestmentORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorFundingDetailsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorFundingDetailsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvestorFundingDetailsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorFundingDetailsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorFundingDetailsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchInvestorFundingDetails executes a basic gorm update call with patch behavior
func DefaultPatchInvestorFundingDetails(ctx context.Context, in *InvestorFundingDetails, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*InvestorFundingDetails, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj InvestorFundingDetails
	var err error
	if hook, ok := interface{}(&pbObj).(InvestorFundingDetailsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvestorFundingDetails(ctx, &InvestorFundingDetails{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvestorFundingDetailsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvestorFundingDetails(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvestorFundingDetailsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvestorFundingDetails(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvestorFundingDetailsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvestorFundingDetailsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *InvestorFundingDetails, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorFundingDetailsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *InvestorFundingDetails, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorFundingDetailsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *InvestorFundingDetails, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorFundingDetailsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *InvestorFundingDetails, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetInvestorFundingDetails executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvestorFundingDetails(ctx context.Context, objects []*InvestorFundingDetails, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*InvestorFundingDetails, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*InvestorFundingDetails, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvestorFundingDetails(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvestorFundingDetails patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvestorFundingDetails(ctx context.Context, patchee *InvestorFundingDetails, patcher *InvestorFundingDetails, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*InvestorFundingDetails, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"InvestorType" {
			patchee.InvestorType = patcher.InvestorType
			continue
		}
		if f == prefix+"InvestmentStage" {
			patchee.InvestmentStage = patcher.InvestmentStage
			continue
		}
		if f == prefix+"NumberOfExits" {
			patchee.NumberOfExits = patcher.NumberOfExits
			continue
		}
		if f == prefix+"NumberOfinvestments" {
			patchee.NumberOfinvestments = patcher.NumberOfinvestments
			continue
		}
		if f == prefix+"NumberOfFunds" {
			patchee.NumberOfFunds = patcher.NumberOfFunds
			continue
		}
		if f == prefix+"Investments" {
			patchee.Investments = patcher.Investments
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvestorFundingDetails executes a gorm list call
func DefaultListInvestorFundingDetails(ctx context.Context, db *gorm1.DB) ([]*InvestorFundingDetails, error) {
	in := InvestorFundingDetails{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorFundingDetailsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &InvestorFundingDetailsORM{}, &InvestorFundingDetails{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorFundingDetailsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvestorFundingDetailsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorFundingDetailsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*InvestorFundingDetails{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvestorFundingDetailsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorFundingDetailsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorFundingDetailsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]InvestorFundingDetailsORM) error
}

// DefaultCreateStartupFundingDetails executes a basic gorm create call
func DefaultCreateStartupFundingDetails(ctx context.Context, in *StartupFundingDetails, db *gorm1.DB) (*StartupFundingDetails, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupFundingDetailsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupFundingDetailsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type StartupFundingDetailsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupFundingDetailsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadStartupFundingDetails executes a basic gorm read call
func DefaultReadStartupFundingDetails(ctx context.Context, in *StartupFundingDetails, db *gorm1.DB) (*StartupFundingDetails, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StartupFundingDetailsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &StartupFundingDetailsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupFundingDetailsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := StartupFundingDetailsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(StartupFundingDetailsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type StartupFundingDetailsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupFundingDetailsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupFundingDetailsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteStartupFundingDetails(ctx context.Context, in *StartupFundingDetails, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StartupFundingDetailsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&StartupFundingDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(StartupFundingDetailsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type StartupFundingDetailsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupFundingDetailsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteStartupFundingDetailsSet(ctx context.Context, in []*StartupFundingDetails, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&StartupFundingDetailsORM{})).(StartupFundingDetailsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&StartupFundingDetailsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&StartupFundingDetailsORM{})).(StartupFundingDetailsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type StartupFundingDetailsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*StartupFundingDetails, *gorm1.DB) (*gorm1.DB, error)
}
type StartupFundingDetailsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*StartupFundingDetails, *gorm1.DB) error
}

// DefaultStrictUpdateStartupFundingDetails clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateStartupFundingDetails(ctx context.Context, in *StartupFundingDetails, db *gorm1.DB) (*StartupFundingDetails, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateStartupFundingDetails")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &StartupFundingDetailsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(StartupFundingDetailsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCompanyDetails := DetailsORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterCompanyDetails.StartupFundingDetailsId = new(uint32)
	*filterCompanyDetails.StartupFundingDetailsId = ormObj.Id
	if err = db.Where(filterCompanyDetails).Delete(DetailsORM{}).Error; err != nil {
		return nil, err
	}
	filterFunding := FundingORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterFunding.StartupFundingDetailsId = new(uint32)
	*filterFunding.StartupFundingDetailsId = ormObj.Id
	if err = db.Where(filterFunding).Delete(FundingORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupFundingDetailsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupFundingDetailsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type StartupFundingDetailsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupFundingDetailsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupFundingDetailsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchStartupFundingDetails executes a basic gorm update call with patch behavior
func DefaultPatchStartupFundingDetails(ctx context.Context, in *StartupFundingDetails, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*StartupFundingDetails, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj StartupFundingDetails
	var err error
	if hook, ok := interface{}(&pbObj).(StartupFundingDetailsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadStartupFundingDetails(ctx, &StartupFundingDetails{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(StartupFundingDetailsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskStartupFundingDetails(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(StartupFundingDetailsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateStartupFundingDetails(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(StartupFundingDetailsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type StartupFundingDetailsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *StartupFundingDetails, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type StartupFundingDetailsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *StartupFundingDetails, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type StartupFundingDetailsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *StartupFundingDetails, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type StartupFundingDetailsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *StartupFundingDetails, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetStartupFundingDetails executes a bulk gorm update call with patch behavior
func DefaultPatchSetStartupFundingDetails(ctx context.Context, objects []*StartupFundingDetails, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*StartupFundingDetails, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*StartupFundingDetails, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchStartupFundingDetails(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskStartupFundingDetails patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskStartupFundingDetails(ctx context.Context, patchee *StartupFundingDetails, patcher *StartupFundingDetails, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*StartupFundingDetails, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedFunding bool
	var updatedCompanyDetails bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedFunding && strings.HasPrefix(f, prefix+"Funding.") {
			updatedFunding = true
			if patcher.Funding == nil {
				patchee.Funding = nil
				continue
			}
			if patchee.Funding == nil {
				patchee.Funding = &Funding{}
			}
			if o, err := DefaultApplyFieldMaskFunding(ctx, patchee.Funding, patcher.Funding, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Funding.", db); err != nil {
				return nil, err
			} else {
				patchee.Funding = o
			}
			continue
		}
		if f == prefix+"Funding" {
			updatedFunding = true
			patchee.Funding = patcher.Funding
			continue
		}
		if !updatedCompanyDetails && strings.HasPrefix(f, prefix+"CompanyDetails.") {
			updatedCompanyDetails = true
			if patcher.CompanyDetails == nil {
				patchee.CompanyDetails = nil
				continue
			}
			if patchee.CompanyDetails == nil {
				patchee.CompanyDetails = &Details{}
			}
			if o, err := DefaultApplyFieldMaskDetails(ctx, patchee.CompanyDetails, patcher.CompanyDetails, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"CompanyDetails.", db); err != nil {
				return nil, err
			} else {
				patchee.CompanyDetails = o
			}
			continue
		}
		if f == prefix+"CompanyDetails" {
			updatedCompanyDetails = true
			patchee.CompanyDetails = patcher.CompanyDetails
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListStartupFundingDetails executes a gorm list call
func DefaultListStartupFundingDetails(ctx context.Context, db *gorm1.DB) ([]*StartupFundingDetails, error) {
	in := StartupFundingDetails{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupFundingDetailsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &StartupFundingDetailsORM{}, &StartupFundingDetails{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupFundingDetailsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []StartupFundingDetailsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupFundingDetailsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*StartupFundingDetails{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type StartupFundingDetailsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupFundingDetailsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupFundingDetailsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]StartupFundingDetailsORM) error
}

// DefaultCreateFunding executes a basic gorm create call
func DefaultCreateFunding(ctx context.Context, in *Funding, db *gorm1.DB) (*Funding, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FundingORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FundingORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FundingORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FundingORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadFunding executes a basic gorm read call
func DefaultReadFunding(ctx context.Context, in *Funding, db *gorm1.DB) (*Funding, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FundingORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &FundingORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FundingORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FundingORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FundingORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FundingORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FundingORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FundingORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteFunding(ctx context.Context, in *Funding, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FundingORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FundingORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FundingORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FundingORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FundingORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteFundingSet(ctx context.Context, in []*Funding, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FundingORM{})).(FundingORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FundingORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FundingORM{})).(FundingORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FundingORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Funding, *gorm1.DB) (*gorm1.DB, error)
}
type FundingORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Funding, *gorm1.DB) error
}

// DefaultStrictUpdateFunding clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFunding(ctx context.Context, in *Funding, db *gorm1.DB) (*Funding, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFunding")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FundingORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FundingORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterInvestors := ProfileORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterInvestors.FundingId = new(int32)
	*filterInvestors.FundingId = ormObj.Id
	if err = db.Where(filterInvestors).Delete(ProfileORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FundingORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FundingORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FundingORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FundingORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FundingORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchFunding executes a basic gorm update call with patch behavior
func DefaultPatchFunding(ctx context.Context, in *Funding, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Funding, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Funding
	var err error
	if hook, ok := interface{}(&pbObj).(FundingWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFunding(ctx, &Funding{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FundingWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFunding(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FundingWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFunding(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FundingWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FundingWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Funding, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FundingWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Funding, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FundingWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Funding, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FundingWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Funding, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetFunding executes a bulk gorm update call with patch behavior
func DefaultPatchSetFunding(ctx context.Context, objects []*Funding, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Funding, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Funding, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFunding(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFunding patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFunding(ctx context.Context, patchee *Funding, patcher *Funding, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Funding, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TotalFunding" {
			patchee.TotalFunding = patcher.TotalFunding
			continue
		}
		if f == prefix+"LatestRound" {
			patchee.LatestRound = patcher.LatestRound
			continue
		}
		if f == prefix+"LatestRoundDate" {
			patchee.LatestRoundDate = patcher.LatestRoundDate
			continue
		}
		if f == prefix+"LatestRoundFunding" {
			patchee.LatestRoundFunding = patcher.LatestRoundFunding
			continue
		}
		if f == prefix+"Investors" {
			patchee.Investors = patcher.Investors
			continue
		}
		if f == prefix+"InvestorType" {
			patchee.InvestorType = patcher.InvestorType
			continue
		}
		if f == prefix+"InvestmentStage" {
			patchee.InvestmentStage = patcher.InvestmentStage
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFunding executes a gorm list call
func DefaultListFunding(ctx context.Context, db *gorm1.DB) ([]*Funding, error) {
	in := Funding{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FundingORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &FundingORM{}, &Funding{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FundingORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FundingORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FundingORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Funding{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FundingORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FundingORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FundingORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]FundingORM) error
}
