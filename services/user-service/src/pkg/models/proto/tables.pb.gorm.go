// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/tables.proto

package user

import context "context"
import fmt "fmt"
import strings "strings"
import time "time"

import auth1 "github.com/infobloxopen/atlas-app-toolkit/auth"
import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import pq1 "github.com/lib/pq"
import ptypes1 "github.com/golang/protobuf/ptypes"

import math "math"
import _ "github.com/mwitkow/go-proto-validators"
import _ "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type UserORM struct {
	AccountID            string
	AdminGroupId         *int32
	AdminIdTeamId        *int32
	AdvisorsTeamId       *int32
	Age                  int32
	BirthDate            string
	CreatedAt            *time.Time
	DeletedAt            *time.Time
	Email                string
	FirstName            string
	Gender               string
	GroupMembersGroupId  *int32
	Id                   int32 `gorm:"type:integer;primary_key"`
	Intent               string
	IsActive             bool
	Languages            string
	LastName             string
	MembersTeamId        *int32
	Password             string
	PasswordConfirmed    string
	PhoneNumber          string
	ProfileId            *ProfileORM `gorm:"foreignkey:ProfileId;association_foreignkey:Id"`
	ResetToken           string
	ResetTokenExpiration *time.Time
	SubscriptionsId      []*SubscriptionsORM `gorm:"foreignkey:UserId;association_foreignkey:Id"`
	UpdatedAt            *time.Time
	UserAccountType      string
	UserName             string
}

// TableName overrides the default tablename generated by GORM
func (UserORM) TableName() string {
	return "users"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *User) ToORM(ctx context.Context) (UserORM, error) {
	to := UserORM{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.UserAccountType = m.UserAccountType
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.UserName = m.UserName
	to.Gender = m.Gender
	to.Languages = m.Languages
	to.Password = m.Password
	to.PasswordConfirmed = m.PasswordConfirmed
	to.Age = m.Age
	to.BirthDate = m.BirthDate
	to.PhoneNumber = m.PhoneNumber
	to.Email = m.Email
	to.Intent = m.Intent
	if m.ProfileId != nil {
		tempProfileId, err := m.ProfileId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ProfileId = &tempProfileId
	}
	to.ResetToken = m.ResetToken
	if m.ResetTokenExpiration != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.ResetTokenExpiration); err != nil {
			return to, err
		}
		to.ResetTokenExpiration = &t
	}
	for _, v := range m.SubscriptionsId {
		if v != nil {
			if tempSubscriptionsId, cErr := v.ToORM(ctx); cErr == nil {
				to.SubscriptionsId = append(to.SubscriptionsId, &tempSubscriptionsId)
			} else {
				return to, cErr
			}
		} else {
			to.SubscriptionsId = append(to.SubscriptionsId, nil)
		}
	}
	to.IsActive = m.IsActive
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(UserWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserORM) ToPB(ctx context.Context) (User, error) {
	to := User{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.UserAccountType = m.UserAccountType
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.UserName = m.UserName
	to.Gender = m.Gender
	to.Languages = m.Languages
	to.Password = m.Password
	to.PasswordConfirmed = m.PasswordConfirmed
	to.Age = m.Age
	to.BirthDate = m.BirthDate
	to.PhoneNumber = m.PhoneNumber
	to.Email = m.Email
	to.Intent = m.Intent
	if m.ProfileId != nil {
		tempProfileId, err := m.ProfileId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ProfileId = &tempProfileId
	}
	to.ResetToken = m.ResetToken
	if m.ResetTokenExpiration != nil {
		if to.ResetTokenExpiration, err = ptypes1.TimestampProto(*m.ResetTokenExpiration); err != nil {
			return to, err
		}
	}
	for _, v := range m.SubscriptionsId {
		if v != nil {
			if tempSubscriptionsId, cErr := v.ToPB(ctx); cErr == nil {
				to.SubscriptionsId = append(to.SubscriptionsId, &tempSubscriptionsId)
			} else {
				return to, cErr
			}
		} else {
			to.SubscriptionsId = append(to.SubscriptionsId, nil)
		}
	}
	to.IsActive = m.IsActive
	if posthook, ok := interface{}(m).(UserWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type User the arg will be the target, the caller the one being converted from

// UserBeforeToORM called before default ToORM code
type UserWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserORM) error
}

// UserAfterToORM called after default ToORM code
type UserWithAfterToORM interface {
	AfterToORM(context.Context, *UserORM) error
}

// UserBeforeToPB called before default ToPB code
type UserWithBeforeToPB interface {
	BeforeToPB(context.Context, *User) error
}

// UserAfterToPB called after default ToPB code
type UserWithAfterToPB interface {
	AfterToPB(context.Context, *User) error
}

type ProfileORM struct {
	AddressId                  *AddressORM `gorm:"foreignkey:AddressId;association_foreignkey:Id"`
	AvatarUrl                  string
	Bio                        string
	BlockedAccountsIdPrivacyId *int32
	CreatedAt                  *time.Time
	DeletedAt                  *time.Time
	EducationId                []*EducationORM  `gorm:"foreignkey:ProfileId;association_foreignkey:Id"`
	ExperienceId               []*ExperienceORM `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:profile_experiences;jointable_foreignkey:profile_id;association_jointable_foreignkey:experience_id"`
	GroupId                    []*GroupORM      `gorm:"foreignkey:Id;association_foreignkey:Id;many2many:profile_groups;jointable_foreignkey:profile_id;association_jointable_foreignkey:group_id"`
	Id                         int32            `gorm:"type:integer;primary_key"`
	MutedAccountsIdPrivacyId   *int32
	Nationality                string
	ProfileType                string
	SettingsId                 *SettingsORM    `gorm:"foreignkey:SettingsId;association_foreignkey:Id"`
	Skills                     pq1.StringArray `gorm:"type:text[]"`
	SocialMedia                *SocialMediaORM `gorm:"foreignkey:SocialMediaId;association_foreignkey:Id"`
	SocialMediaId              *int32
	TeamId                     *TeamORM `gorm:"foreignkey:TeamId;association_foreignkey:Id"`
	UpdatedAt                  *time.Time
}

// TableName overrides the default tablename generated by GORM
func (ProfileORM) TableName() string {
	return "profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Profile) ToORM(ctx context.Context) (ProfileORM, error) {
	to := ProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(ProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Bio = m.Bio
	for _, v := range m.ExperienceId {
		if v != nil {
			if tempExperienceId, cErr := v.ToORM(ctx); cErr == nil {
				to.ExperienceId = append(to.ExperienceId, &tempExperienceId)
			} else {
				return to, cErr
			}
		} else {
			to.ExperienceId = append(to.ExperienceId, nil)
		}
	}
	if m.AddressId != nil {
		tempAddressId, err := m.AddressId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.AddressId = &tempAddressId
	}
	for _, v := range m.EducationId {
		if v != nil {
			if tempEducationId, cErr := v.ToORM(ctx); cErr == nil {
				to.EducationId = append(to.EducationId, &tempEducationId)
			} else {
				return to, cErr
			}
		} else {
			to.EducationId = append(to.EducationId, nil)
		}
	}
	if m.Skills != nil {
		to.Skills = make(pq1.StringArray, len(m.Skills))
		copy(to.Skills, m.Skills)
	}
	if m.TeamId != nil {
		tempTeamId, err := m.TeamId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.TeamId = &tempTeamId
	}
	for _, v := range m.GroupId {
		if v != nil {
			if tempGroupId, cErr := v.ToORM(ctx); cErr == nil {
				to.GroupId = append(to.GroupId, &tempGroupId)
			} else {
				return to, cErr
			}
		} else {
			to.GroupId = append(to.GroupId, nil)
		}
	}
	if m.SocialMedia != nil {
		tempSocialMedia, err := m.SocialMedia.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.SocialMedia = &tempSocialMedia
	}
	if m.SettingsId != nil {
		tempSettingsId, err := m.SettingsId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.SettingsId = &tempSettingsId
	}
	to.ProfileType = m.ProfileType
	to.Nationality = m.Nationality
	to.AvatarUrl = m.AvatarUrl
	if posthook, ok := interface{}(m).(ProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ProfileORM) ToPB(ctx context.Context) (Profile, error) {
	to := Profile{}
	var err error
	if prehook, ok := interface{}(m).(ProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Bio = m.Bio
	for _, v := range m.ExperienceId {
		if v != nil {
			if tempExperienceId, cErr := v.ToPB(ctx); cErr == nil {
				to.ExperienceId = append(to.ExperienceId, &tempExperienceId)
			} else {
				return to, cErr
			}
		} else {
			to.ExperienceId = append(to.ExperienceId, nil)
		}
	}
	if m.AddressId != nil {
		tempAddressId, err := m.AddressId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.AddressId = &tempAddressId
	}
	for _, v := range m.EducationId {
		if v != nil {
			if tempEducationId, cErr := v.ToPB(ctx); cErr == nil {
				to.EducationId = append(to.EducationId, &tempEducationId)
			} else {
				return to, cErr
			}
		} else {
			to.EducationId = append(to.EducationId, nil)
		}
	}
	if m.Skills != nil {
		to.Skills = make(pq1.StringArray, len(m.Skills))
		copy(to.Skills, m.Skills)
	}
	if m.TeamId != nil {
		tempTeamId, err := m.TeamId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.TeamId = &tempTeamId
	}
	for _, v := range m.GroupId {
		if v != nil {
			if tempGroupId, cErr := v.ToPB(ctx); cErr == nil {
				to.GroupId = append(to.GroupId, &tempGroupId)
			} else {
				return to, cErr
			}
		} else {
			to.GroupId = append(to.GroupId, nil)
		}
	}
	if m.SocialMedia != nil {
		tempSocialMedia, err := m.SocialMedia.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.SocialMedia = &tempSocialMedia
	}
	if m.SettingsId != nil {
		tempSettingsId, err := m.SettingsId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.SettingsId = &tempSettingsId
	}
	to.ProfileType = m.ProfileType
	to.Nationality = m.Nationality
	to.AvatarUrl = m.AvatarUrl
	if posthook, ok := interface{}(m).(ProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Profile the arg will be the target, the caller the one being converted from

// ProfileBeforeToORM called before default ToORM code
type ProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *ProfileORM) error
}

// ProfileAfterToORM called after default ToORM code
type ProfileWithAfterToORM interface {
	AfterToORM(context.Context, *ProfileORM) error
}

// ProfileBeforeToPB called before default ToPB code
type ProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *Profile) error
}

// ProfileAfterToPB called after default ToPB code
type ProfileWithAfterToPB interface {
	AfterToPB(context.Context, *Profile) error
}

type GroupORM struct {
	Admin           *UserORM `gorm:"foreignkey:AdminGroupId;association_foreignkey:Id"`
	AvatarUrl       string
	Bio             string
	CreatedAt       *time.Time
	DeletedAt       *time.Time
	GroupMembers    []*UserORM `gorm:"foreignkey:GroupMembersGroupId;association_foreignkey:Id"`
	Id              int32      `gorm:"type:integer;primary_key"`
	IsPublic        bool
	Name            string
	NumberOfMembers int32
	Tags            pq1.StringArray `gorm:"type:text[]"`
	Type            string
	UpdatedAt       *time.Time
}

// TableName overrides the default tablename generated by GORM
func (GroupORM) TableName() string {
	return "groups"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Group) ToORM(ctx context.Context) (GroupORM, error) {
	to := GroupORM{}
	var err error
	if prehook, ok := interface{}(m).(GroupWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Type = m.Type
	to.Name = m.Name
	to.Bio = m.Bio
	if m.Tags != nil {
		to.Tags = make(pq1.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	to.NumberOfMembers = m.NumberOfMembers
	for _, v := range m.GroupMembers {
		if v != nil {
			if tempGroupMembers, cErr := v.ToORM(ctx); cErr == nil {
				to.GroupMembers = append(to.GroupMembers, &tempGroupMembers)
			} else {
				return to, cErr
			}
		} else {
			to.GroupMembers = append(to.GroupMembers, nil)
		}
	}
	to.IsPublic = m.IsPublic
	if m.Admin != nil {
		tempAdmin, err := m.Admin.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Admin = &tempAdmin
	}
	to.AvatarUrl = m.AvatarUrl
	if posthook, ok := interface{}(m).(GroupWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *GroupORM) ToPB(ctx context.Context) (Group, error) {
	to := Group{}
	var err error
	if prehook, ok := interface{}(m).(GroupWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Type = m.Type
	to.Name = m.Name
	to.Bio = m.Bio
	if m.Tags != nil {
		to.Tags = make(pq1.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	to.NumberOfMembers = m.NumberOfMembers
	for _, v := range m.GroupMembers {
		if v != nil {
			if tempGroupMembers, cErr := v.ToPB(ctx); cErr == nil {
				to.GroupMembers = append(to.GroupMembers, &tempGroupMembers)
			} else {
				return to, cErr
			}
		} else {
			to.GroupMembers = append(to.GroupMembers, nil)
		}
	}
	to.IsPublic = m.IsPublic
	if m.Admin != nil {
		tempAdmin, err := m.Admin.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Admin = &tempAdmin
	}
	to.AvatarUrl = m.AvatarUrl
	if posthook, ok := interface{}(m).(GroupWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Group the arg will be the target, the caller the one being converted from

// GroupBeforeToORM called before default ToORM code
type GroupWithBeforeToORM interface {
	BeforeToORM(context.Context, *GroupORM) error
}

// GroupAfterToORM called after default ToORM code
type GroupWithAfterToORM interface {
	AfterToORM(context.Context, *GroupORM) error
}

// GroupBeforeToPB called before default ToPB code
type GroupWithBeforeToPB interface {
	BeforeToPB(context.Context, *Group) error
}

// GroupAfterToPB called after default ToPB code
type GroupWithAfterToPB interface {
	AfterToPB(context.Context, *Group) error
}

type TeamORM struct {
	AdminId              *UserORM   `gorm:"foreignkey:AdminIdTeamId;association_foreignkey:Id"`
	Advisors             []*UserORM `gorm:"foreignkey:AdvisorsTeamId;association_foreignkey:Id"`
	Bio                  string
	CreatedAt            *time.Time
	DeletedAt            *time.Time
	Email                string
	FoundedDate          *time.Time
	HeadquartersId       *AddressORM `gorm:"foreignkey:TeamId;association_foreignkey:Id"`
	Id                   int32       `gorm:"type:integer;primary_key"`
	Industry             string
	IsActive             bool
	Members              []*UserORM `gorm:"foreignkey:MembersTeamId;association_foreignkey:Id"`
	Name                 string
	NumberOfEmployees    int32
	Password             string
	PhoneNumber          string
	ResetToken           string
	ResetTokenExpiration *time.Time
	SocialMedia          *SocialMediaORM     `gorm:"foreignkey:TeamId;association_foreignkey:Id"`
	Subscriptions        []*SubscriptionsORM `gorm:"foreignkey:TeamId;association_foreignkey:Id"`
	Tags                 pq1.StringArray     `gorm:"type:text[]"`
	TeamProfileId        *TeamProfileORM     `gorm:"foreignkey:TeamId;association_foreignkey:Id"`
	Type                 string
	UpdatedAt            *time.Time
}

// TableName overrides the default tablename generated by GORM
func (TeamORM) TableName() string {
	return "teams"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Team) ToORM(ctx context.Context) (TeamORM, error) {
	to := TeamORM{}
	var err error
	if prehook, ok := interface{}(m).(TeamWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.Name = m.Name
	if m.Tags != nil {
		to.Tags = make(pq1.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	to.Email = m.Email
	to.Type = m.Type
	to.Industry = m.Industry
	if m.FoundedDate != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.FoundedDate); err != nil {
			return to, err
		}
		to.FoundedDate = &t
	}
	to.NumberOfEmployees = m.NumberOfEmployees
	if m.HeadquartersId != nil {
		tempHeadquartersId, err := m.HeadquartersId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.HeadquartersId = &tempHeadquartersId
	}
	for _, v := range m.Members {
		if v != nil {
			if tempMembers, cErr := v.ToORM(ctx); cErr == nil {
				to.Members = append(to.Members, &tempMembers)
			} else {
				return to, cErr
			}
		} else {
			to.Members = append(to.Members, nil)
		}
	}
	for _, v := range m.Advisors {
		if v != nil {
			if tempAdvisors, cErr := v.ToORM(ctx); cErr == nil {
				to.Advisors = append(to.Advisors, &tempAdvisors)
			} else {
				return to, cErr
			}
		} else {
			to.Advisors = append(to.Advisors, nil)
		}
	}
	if m.SocialMedia != nil {
		tempSocialMedia, err := m.SocialMedia.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.SocialMedia = &tempSocialMedia
	}
	to.PhoneNumber = m.PhoneNumber
	to.Password = m.Password
	if m.TeamProfileId != nil {
		tempTeamProfileId, err := m.TeamProfileId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.TeamProfileId = &tempTeamProfileId
	}
	for _, v := range m.Subscriptions {
		if v != nil {
			if tempSubscriptions, cErr := v.ToORM(ctx); cErr == nil {
				to.Subscriptions = append(to.Subscriptions, &tempSubscriptions)
			} else {
				return to, cErr
			}
		} else {
			to.Subscriptions = append(to.Subscriptions, nil)
		}
	}
	to.IsActive = m.IsActive
	to.ResetToken = m.ResetToken
	if m.ResetTokenExpiration != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.ResetTokenExpiration); err != nil {
			return to, err
		}
		to.ResetTokenExpiration = &t
	}
	if m.AdminId != nil {
		tempAdminId, err := m.AdminId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.AdminId = &tempAdminId
	}
	to.Bio = m.Bio
	if posthook, ok := interface{}(m).(TeamWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TeamORM) ToPB(ctx context.Context) (Team, error) {
	to := Team{}
	var err error
	if prehook, ok := interface{}(m).(TeamWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	if m.Tags != nil {
		to.Tags = make(pq1.StringArray, len(m.Tags))
		copy(to.Tags, m.Tags)
	}
	to.Email = m.Email
	to.Type = m.Type
	to.Industry = m.Industry
	if m.FoundedDate != nil {
		if to.FoundedDate, err = ptypes1.TimestampProto(*m.FoundedDate); err != nil {
			return to, err
		}
	}
	to.NumberOfEmployees = m.NumberOfEmployees
	if m.HeadquartersId != nil {
		tempHeadquartersId, err := m.HeadquartersId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.HeadquartersId = &tempHeadquartersId
	}
	for _, v := range m.Members {
		if v != nil {
			if tempMembers, cErr := v.ToPB(ctx); cErr == nil {
				to.Members = append(to.Members, &tempMembers)
			} else {
				return to, cErr
			}
		} else {
			to.Members = append(to.Members, nil)
		}
	}
	for _, v := range m.Advisors {
		if v != nil {
			if tempAdvisors, cErr := v.ToPB(ctx); cErr == nil {
				to.Advisors = append(to.Advisors, &tempAdvisors)
			} else {
				return to, cErr
			}
		} else {
			to.Advisors = append(to.Advisors, nil)
		}
	}
	if m.SocialMedia != nil {
		tempSocialMedia, err := m.SocialMedia.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.SocialMedia = &tempSocialMedia
	}
	to.PhoneNumber = m.PhoneNumber
	to.Password = m.Password
	if m.TeamProfileId != nil {
		tempTeamProfileId, err := m.TeamProfileId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.TeamProfileId = &tempTeamProfileId
	}
	for _, v := range m.Subscriptions {
		if v != nil {
			if tempSubscriptions, cErr := v.ToPB(ctx); cErr == nil {
				to.Subscriptions = append(to.Subscriptions, &tempSubscriptions)
			} else {
				return to, cErr
			}
		} else {
			to.Subscriptions = append(to.Subscriptions, nil)
		}
	}
	to.IsActive = m.IsActive
	to.ResetToken = m.ResetToken
	if m.ResetTokenExpiration != nil {
		if to.ResetTokenExpiration, err = ptypes1.TimestampProto(*m.ResetTokenExpiration); err != nil {
			return to, err
		}
	}
	if m.AdminId != nil {
		tempAdminId, err := m.AdminId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.AdminId = &tempAdminId
	}
	to.Bio = m.Bio
	if posthook, ok := interface{}(m).(TeamWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Team the arg will be the target, the caller the one being converted from

// TeamBeforeToORM called before default ToORM code
type TeamWithBeforeToORM interface {
	BeforeToORM(context.Context, *TeamORM) error
}

// TeamAfterToORM called after default ToORM code
type TeamWithAfterToORM interface {
	AfterToORM(context.Context, *TeamORM) error
}

// TeamBeforeToPB called before default ToPB code
type TeamWithBeforeToPB interface {
	BeforeToPB(context.Context, *Team) error
}

// TeamAfterToPB called after default ToPB code
type TeamWithAfterToPB interface {
	AfterToPB(context.Context, *Team) error
}

type TeamProfileORM struct {
	BlockedTeamAccountsIdPrivacyId *int32
	CreatedAt                      *time.Time
	DeletedAt                      *time.Time
	Id                             int32              `gorm:"type:integer;primary_key"`
	InvestorDetailId               *InvestorDetailORM `gorm:"foreignkey:TeamProfileId;association_foreignkey:Id"`
	MediaId                        *MediaORM          `gorm:"foreignkey:TeamProfileId;association_foreignkey:Id"`
	MutedTeamAccountsIdPrivacyId   *int32
	SettingsId                     *SettingsORM      `gorm:"foreignkey:TeamProfileId;association_foreignkey:Id"`
	StartupDetailId                *StartupDetailORM `gorm:"foreignkey:TeamProfileId;association_foreignkey:Id"`
	TeamId                         *int32
	UpdatedAt                      *time.Time
}

// TableName overrides the default tablename generated by GORM
func (TeamProfileORM) TableName() string {
	return "team_profiles"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *TeamProfile) ToORM(ctx context.Context) (TeamProfileORM, error) {
	to := TeamProfileORM{}
	var err error
	if prehook, ok := interface{}(m).(TeamProfileWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.SettingsId != nil {
		tempSettingsId, err := m.SettingsId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.SettingsId = &tempSettingsId
	}
	if m.InvestorDetailId != nil {
		tempInvestorDetailId, err := m.InvestorDetailId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.InvestorDetailId = &tempInvestorDetailId
	}
	if m.StartupDetailId != nil {
		tempStartupDetailId, err := m.StartupDetailId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.StartupDetailId = &tempStartupDetailId
	}
	if m.MediaId != nil {
		tempMediaId, err := m.MediaId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.MediaId = &tempMediaId
	}
	if posthook, ok := interface{}(m).(TeamProfileWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TeamProfileORM) ToPB(ctx context.Context) (TeamProfile, error) {
	to := TeamProfile{}
	var err error
	if prehook, ok := interface{}(m).(TeamProfileWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.SettingsId != nil {
		tempSettingsId, err := m.SettingsId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.SettingsId = &tempSettingsId
	}
	if m.InvestorDetailId != nil {
		tempInvestorDetailId, err := m.InvestorDetailId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.InvestorDetailId = &tempInvestorDetailId
	}
	if m.StartupDetailId != nil {
		tempStartupDetailId, err := m.StartupDetailId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.StartupDetailId = &tempStartupDetailId
	}
	if m.MediaId != nil {
		tempMediaId, err := m.MediaId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.MediaId = &tempMediaId
	}
	if posthook, ok := interface{}(m).(TeamProfileWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type TeamProfile the arg will be the target, the caller the one being converted from

// TeamProfileBeforeToORM called before default ToORM code
type TeamProfileWithBeforeToORM interface {
	BeforeToORM(context.Context, *TeamProfileORM) error
}

// TeamProfileAfterToORM called after default ToORM code
type TeamProfileWithAfterToORM interface {
	AfterToORM(context.Context, *TeamProfileORM) error
}

// TeamProfileBeforeToPB called before default ToPB code
type TeamProfileWithBeforeToPB interface {
	BeforeToPB(context.Context, *TeamProfile) error
}

// TeamProfileAfterToPB called after default ToPB code
type TeamProfileWithAfterToPB interface {
	AfterToPB(context.Context, *TeamProfile) error
}

type InvestorDetailORM struct {
	CreatedAt           *time.Time
	DeletedAt           *time.Time
	Id                  uint32 `gorm:"type:integer;primary_key"`
	InvestmentStage     int32
	InvestmentsId       []*InvestmentORM `gorm:"foreignkey:InvestorDetailId;association_foreignkey:Id"`
	InvestorType        int32
	NumberOfExits       int32
	NumberOfFunds       int32
	NumberOfInvestments int32
	TeamProfileId       *int32
	UpdatedAt           *time.Time
}

// TableName overrides the default tablename generated by GORM
func (InvestorDetailORM) TableName() string {
	return "investor_details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *InvestorDetail) ToORM(ctx context.Context) (InvestorDetailORM, error) {
	to := InvestorDetailORM{}
	var err error
	if prehook, ok := interface{}(m).(InvestorDetailWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.InvestorType = int32(m.InvestorType)
	to.InvestmentStage = int32(m.InvestmentStage)
	to.NumberOfExits = m.NumberOfExits
	to.NumberOfInvestments = m.NumberOfInvestments
	to.NumberOfFunds = m.NumberOfFunds
	for _, v := range m.InvestmentsId {
		if v != nil {
			if tempInvestmentsId, cErr := v.ToORM(ctx); cErr == nil {
				to.InvestmentsId = append(to.InvestmentsId, &tempInvestmentsId)
			} else {
				return to, cErr
			}
		} else {
			to.InvestmentsId = append(to.InvestmentsId, nil)
		}
	}
	if posthook, ok := interface{}(m).(InvestorDetailWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvestorDetailORM) ToPB(ctx context.Context) (InvestorDetail, error) {
	to := InvestorDetail{}
	var err error
	if prehook, ok := interface{}(m).(InvestorDetailWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.InvestorType = InvestorType(m.InvestorType)
	to.InvestmentStage = InvestmentStage(m.InvestmentStage)
	to.NumberOfExits = m.NumberOfExits
	to.NumberOfInvestments = m.NumberOfInvestments
	to.NumberOfFunds = m.NumberOfFunds
	for _, v := range m.InvestmentsId {
		if v != nil {
			if tempInvestmentsId, cErr := v.ToPB(ctx); cErr == nil {
				to.InvestmentsId = append(to.InvestmentsId, &tempInvestmentsId)
			} else {
				return to, cErr
			}
		} else {
			to.InvestmentsId = append(to.InvestmentsId, nil)
		}
	}
	if posthook, ok := interface{}(m).(InvestorDetailWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type InvestorDetail the arg will be the target, the caller the one being converted from

// InvestorDetailBeforeToORM called before default ToORM code
type InvestorDetailWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvestorDetailORM) error
}

// InvestorDetailAfterToORM called after default ToORM code
type InvestorDetailWithAfterToORM interface {
	AfterToORM(context.Context, *InvestorDetailORM) error
}

// InvestorDetailBeforeToPB called before default ToPB code
type InvestorDetailWithBeforeToPB interface {
	BeforeToPB(context.Context, *InvestorDetail) error
}

// InvestorDetailAfterToPB called after default ToPB code
type InvestorDetailWithAfterToPB interface {
	AfterToPB(context.Context, *InvestorDetail) error
}

type StartupDetailORM struct {
	CompanyName        string
	CreatedAt          *time.Time
	DeletedAt          *time.Time
	FundingType        string
	Id                 uint32 `gorm:"type:integer;primary_key"`
	LatestRound        string
	LatestRoundEndDate *time.Time
	LatestRoundFunding int32
	TeamProfileId      *int32
	TotalFunding       int32
	UpdatedAt          *time.Time
}

// TableName overrides the default tablename generated by GORM
func (StartupDetailORM) TableName() string {
	return "startup_details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *StartupDetail) ToORM(ctx context.Context) (StartupDetailORM, error) {
	to := StartupDetailORM{}
	var err error
	if prehook, ok := interface{}(m).(StartupDetailWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.TotalFunding = m.TotalFunding
	to.LatestRoundFunding = m.LatestRoundFunding
	to.LatestRound = m.LatestRound
	if m.LatestRoundEndDate != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.LatestRoundEndDate); err != nil {
			return to, err
		}
		to.LatestRoundEndDate = &t
	}
	to.FundingType = m.FundingType
	to.CompanyName = m.CompanyName
	if posthook, ok := interface{}(m).(StartupDetailWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *StartupDetailORM) ToPB(ctx context.Context) (StartupDetail, error) {
	to := StartupDetail{}
	var err error
	if prehook, ok := interface{}(m).(StartupDetailWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.TotalFunding = m.TotalFunding
	to.LatestRoundFunding = m.LatestRoundFunding
	to.LatestRound = m.LatestRound
	if m.LatestRoundEndDate != nil {
		if to.LatestRoundEndDate, err = ptypes1.TimestampProto(*m.LatestRoundEndDate); err != nil {
			return to, err
		}
	}
	to.FundingType = m.FundingType
	to.CompanyName = m.CompanyName
	if posthook, ok := interface{}(m).(StartupDetailWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type StartupDetail the arg will be the target, the caller the one being converted from

// StartupDetailBeforeToORM called before default ToORM code
type StartupDetailWithBeforeToORM interface {
	BeforeToORM(context.Context, *StartupDetailORM) error
}

// StartupDetailAfterToORM called after default ToORM code
type StartupDetailWithAfterToORM interface {
	AfterToORM(context.Context, *StartupDetailORM) error
}

// StartupDetailBeforeToPB called before default ToPB code
type StartupDetailWithBeforeToPB interface {
	BeforeToPB(context.Context, *StartupDetail) error
}

// StartupDetailAfterToPB called after default ToPB code
type StartupDetailWithAfterToPB interface {
	AfterToPB(context.Context, *StartupDetail) error
}

type SettingsORM struct {
	CreatedAt         *time.Time
	DeletedAt         *time.Time
	Id                int32 `gorm:"type:integer;primary_key"`
	LastLogin         *time.Time
	LastLoginLocation string
	NotificationId    *NotificationORM `gorm:"foreignkey:SettingsId;association_foreignkey:Id"`
	PaymentId         *PaymentsORM     `gorm:"foreignkey:SettingsId;association_foreignkey:Id"`
	PrivacyId         *PrivacyORM      `gorm:"foreignkey:SettingsId;association_foreignkey:Id"`
	TeamProfileId     *int32
	UpdatedAt         *time.Time
}

// TableName overrides the default tablename generated by GORM
func (SettingsORM) TableName() string {
	return "settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Settings) ToORM(ctx context.Context) (SettingsORM, error) {
	to := SettingsORM{}
	var err error
	if prehook, ok := interface{}(m).(SettingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.LastLogin != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.LastLogin); err != nil {
			return to, err
		}
		to.LastLogin = &t
	}
	to.LastLoginLocation = m.LastLoginLocation
	if m.NotificationId != nil {
		tempNotificationId, err := m.NotificationId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.NotificationId = &tempNotificationId
	}
	if m.PrivacyId != nil {
		tempPrivacyId, err := m.PrivacyId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.PrivacyId = &tempPrivacyId
	}
	if m.PaymentId != nil {
		tempPaymentId, err := m.PaymentId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.PaymentId = &tempPaymentId
	}
	if posthook, ok := interface{}(m).(SettingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SettingsORM) ToPB(ctx context.Context) (Settings, error) {
	to := Settings{}
	var err error
	if prehook, ok := interface{}(m).(SettingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.LastLogin != nil {
		if to.LastLogin, err = ptypes1.TimestampProto(*m.LastLogin); err != nil {
			return to, err
		}
	}
	to.LastLoginLocation = m.LastLoginLocation
	if m.NotificationId != nil {
		tempNotificationId, err := m.NotificationId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.NotificationId = &tempNotificationId
	}
	if m.PrivacyId != nil {
		tempPrivacyId, err := m.PrivacyId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.PrivacyId = &tempPrivacyId
	}
	if m.PaymentId != nil {
		tempPaymentId, err := m.PaymentId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.PaymentId = &tempPaymentId
	}
	if posthook, ok := interface{}(m).(SettingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Settings the arg will be the target, the caller the one being converted from

// SettingsBeforeToORM called before default ToORM code
type SettingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *SettingsORM) error
}

// SettingsAfterToORM called after default ToORM code
type SettingsWithAfterToORM interface {
	AfterToORM(context.Context, *SettingsORM) error
}

// SettingsBeforeToPB called before default ToPB code
type SettingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Settings) error
}

// SettingsAfterToPB called after default ToPB code
type SettingsWithAfterToPB interface {
	AfterToPB(context.Context, *Settings) error
}

type LoginActivityORM struct {
	Date     string
	Id       int32       `gorm:"type:integer;primary_key"`
	Location *AddressORM `gorm:"foreignkey:LoginActivityId;association_foreignkey:Id"`
}

// TableName overrides the default tablename generated by GORM
func (LoginActivityORM) TableName() string {
	return "login_activities"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LoginActivity) ToORM(ctx context.Context) (LoginActivityORM, error) {
	to := LoginActivityORM{}
	var err error
	if prehook, ok := interface{}(m).(LoginActivityWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Location != nil {
		tempLocation, err := m.Location.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Location = &tempLocation
	}
	to.Date = m.Date
	if posthook, ok := interface{}(m).(LoginActivityWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LoginActivityORM) ToPB(ctx context.Context) (LoginActivity, error) {
	to := LoginActivity{}
	var err error
	if prehook, ok := interface{}(m).(LoginActivityWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Location != nil {
		tempLocation, err := m.Location.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Location = &tempLocation
	}
	to.Date = m.Date
	if posthook, ok := interface{}(m).(LoginActivityWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LoginActivity the arg will be the target, the caller the one being converted from

// LoginActivityBeforeToORM called before default ToORM code
type LoginActivityWithBeforeToORM interface {
	BeforeToORM(context.Context, *LoginActivityORM) error
}

// LoginActivityAfterToORM called after default ToORM code
type LoginActivityWithAfterToORM interface {
	AfterToORM(context.Context, *LoginActivityORM) error
}

// LoginActivityBeforeToPB called before default ToPB code
type LoginActivityWithBeforeToPB interface {
	BeforeToPB(context.Context, *LoginActivity) error
}

// LoginActivityAfterToPB called after default ToPB code
type LoginActivityWithAfterToPB interface {
	AfterToPB(context.Context, *LoginActivity) error
}

type PaymentsORM struct {
	CreatedAt  *time.Time
	CreditCard *CardORM `gorm:"foreignkey:CreditCardPaymentsId;association_foreignkey:Id"`
	DebitCard  *CardORM `gorm:"foreignkey:DebitCardPaymentsId;association_foreignkey:Id"`
	DeletedAt  *time.Time
	Id         int32 `gorm:"type:integer;primary_key"`
	LastLogin  *time.Time
	Pin        *PinORM `gorm:"foreignkey:PaymentsId;association_foreignkey:Id"`
	SettingsId *int32
	UpdatedAt  *time.Time
}

// TableName overrides the default tablename generated by GORM
func (PaymentsORM) TableName() string {
	return "payments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Payments) ToORM(ctx context.Context) (PaymentsORM, error) {
	to := PaymentsORM{}
	var err error
	if prehook, ok := interface{}(m).(PaymentsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.LastLogin != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.LastLogin); err != nil {
			return to, err
		}
		to.LastLogin = &t
	}
	if m.DebitCard != nil {
		tempDebitCard, err := m.DebitCard.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.DebitCard = &tempDebitCard
	}
	if m.CreditCard != nil {
		tempCreditCard, err := m.CreditCard.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.CreditCard = &tempCreditCard
	}
	if m.Pin != nil {
		tempPin, err := m.Pin.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Pin = &tempPin
	}
	if posthook, ok := interface{}(m).(PaymentsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PaymentsORM) ToPB(ctx context.Context) (Payments, error) {
	to := Payments{}
	var err error
	if prehook, ok := interface{}(m).(PaymentsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.LastLogin != nil {
		if to.LastLogin, err = ptypes1.TimestampProto(*m.LastLogin); err != nil {
			return to, err
		}
	}
	if m.DebitCard != nil {
		tempDebitCard, err := m.DebitCard.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.DebitCard = &tempDebitCard
	}
	if m.CreditCard != nil {
		tempCreditCard, err := m.CreditCard.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.CreditCard = &tempCreditCard
	}
	if m.Pin != nil {
		tempPin, err := m.Pin.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Pin = &tempPin
	}
	if posthook, ok := interface{}(m).(PaymentsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Payments the arg will be the target, the caller the one being converted from

// PaymentsBeforeToORM called before default ToORM code
type PaymentsWithBeforeToORM interface {
	BeforeToORM(context.Context, *PaymentsORM) error
}

// PaymentsAfterToORM called after default ToORM code
type PaymentsWithAfterToORM interface {
	AfterToORM(context.Context, *PaymentsORM) error
}

// PaymentsBeforeToPB called before default ToPB code
type PaymentsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Payments) error
}

// PaymentsAfterToPB called after default ToPB code
type PaymentsWithAfterToPB interface {
	AfterToPB(context.Context, *Payments) error
}

type CardORM struct {
	Address              string
	CardNumber           string
	CardZipCode          string
	City                 string
	CreatedAt            *time.Time
	CreditCardPaymentsId *int32
	DebitCardPaymentsId  *int32
	DeletedAt            *time.Time
	FullName             string
	Id                   int32 `gorm:"type:integer;primary_key"`
	LastLogin            *time.Time
	SecurityCode         string
	State                string
	UpdatedAt            *time.Time
	Zipcode              string
}

// TableName overrides the default tablename generated by GORM
func (CardORM) TableName() string {
	return "cards"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Card) ToORM(ctx context.Context) (CardORM, error) {
	to := CardORM{}
	var err error
	if prehook, ok := interface{}(m).(CardWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.LastLogin != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.LastLogin); err != nil {
			return to, err
		}
		to.LastLogin = &t
	}
	to.CardNumber = m.CardNumber
	to.SecurityCode = m.SecurityCode
	to.CardZipCode = m.CardZipCode
	to.FullName = m.FullName
	to.City = m.City
	to.State = m.State
	to.Zipcode = m.Zipcode
	to.Address = m.Address
	if posthook, ok := interface{}(m).(CardWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CardORM) ToPB(ctx context.Context) (Card, error) {
	to := Card{}
	var err error
	if prehook, ok := interface{}(m).(CardWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.LastLogin != nil {
		if to.LastLogin, err = ptypes1.TimestampProto(*m.LastLogin); err != nil {
			return to, err
		}
	}
	to.CardNumber = m.CardNumber
	to.SecurityCode = m.SecurityCode
	to.CardZipCode = m.CardZipCode
	to.FullName = m.FullName
	to.City = m.City
	to.State = m.State
	to.Zipcode = m.Zipcode
	to.Address = m.Address
	if posthook, ok := interface{}(m).(CardWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Card the arg will be the target, the caller the one being converted from

// CardBeforeToORM called before default ToORM code
type CardWithBeforeToORM interface {
	BeforeToORM(context.Context, *CardORM) error
}

// CardAfterToORM called after default ToORM code
type CardWithAfterToORM interface {
	AfterToORM(context.Context, *CardORM) error
}

// CardBeforeToPB called before default ToPB code
type CardWithBeforeToPB interface {
	BeforeToPB(context.Context, *Card) error
}

// CardAfterToPB called after default ToPB code
type CardWithAfterToPB interface {
	AfterToPB(context.Context, *Card) error
}

type PinORM struct {
	CreatedAt  *time.Time
	DeletedAt  *time.Time
	Id         int32 `gorm:"type:integer;primary_key"`
	LastLogin  *time.Time
	PaymentsId *int32
	Pin        string
	PinEnabled bool
	UpdatedAt  *time.Time
}

// TableName overrides the default tablename generated by GORM
func (PinORM) TableName() string {
	return "pins"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Pin) ToORM(ctx context.Context) (PinORM, error) {
	to := PinORM{}
	var err error
	if prehook, ok := interface{}(m).(PinWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if m.LastLogin != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.LastLogin); err != nil {
			return to, err
		}
		to.LastLogin = &t
	}
	to.PinEnabled = m.PinEnabled
	to.Pin = m.Pin
	if posthook, ok := interface{}(m).(PinWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PinORM) ToPB(ctx context.Context) (Pin, error) {
	to := Pin{}
	var err error
	if prehook, ok := interface{}(m).(PinWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if m.LastLogin != nil {
		if to.LastLogin, err = ptypes1.TimestampProto(*m.LastLogin); err != nil {
			return to, err
		}
	}
	to.PinEnabled = m.PinEnabled
	to.Pin = m.Pin
	if posthook, ok := interface{}(m).(PinWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Pin the arg will be the target, the caller the one being converted from

// PinBeforeToORM called before default ToORM code
type PinWithBeforeToORM interface {
	BeforeToORM(context.Context, *PinORM) error
}

// PinAfterToORM called after default ToORM code
type PinWithAfterToORM interface {
	AfterToORM(context.Context, *PinORM) error
}

// PinBeforeToPB called before default ToPB code
type PinWithBeforeToPB interface {
	BeforeToPB(context.Context, *Pin) error
}

// PinAfterToPB called after default ToPB code
type PinWithAfterToPB interface {
	AfterToPB(context.Context, *Pin) error
}

type PrivacyORM struct {
	ActivityStatus        bool
	BlockedAccountsId     []*ProfileORM     `gorm:"foreignkey:BlockedAccountsIdPrivacyId;association_foreignkey:Id"`
	BlockedTeamAccountsId []*TeamProfileORM `gorm:"foreignkey:BlockedTeamAccountsIdPrivacyId;association_foreignkey:Id"`
	CreatedAt             *time.Time
	DeletedAt             *time.Time
	Id                    int32             `gorm:"type:integer;primary_key"`
	MutedAccountsId       []*ProfileORM     `gorm:"foreignkey:MutedAccountsIdPrivacyId;association_foreignkey:Id"`
	MutedTeamAccountsId   []*TeamProfileORM `gorm:"foreignkey:MutedTeamAccountsIdPrivacyId;association_foreignkey:Id"`
	PrivateAccount        bool
	SettingsId            *int32
	UpdatedAt             *time.Time
}

// TableName overrides the default tablename generated by GORM
func (PrivacyORM) TableName() string {
	return "privacies"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Privacy) ToORM(ctx context.Context) (PrivacyORM, error) {
	to := PrivacyORM{}
	var err error
	if prehook, ok := interface{}(m).(PrivacyWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	to.ActivityStatus = m.ActivityStatus
	to.PrivateAccount = m.PrivateAccount
	for _, v := range m.BlockedAccountsId {
		if v != nil {
			if tempBlockedAccountsId, cErr := v.ToORM(ctx); cErr == nil {
				to.BlockedAccountsId = append(to.BlockedAccountsId, &tempBlockedAccountsId)
			} else {
				return to, cErr
			}
		} else {
			to.BlockedAccountsId = append(to.BlockedAccountsId, nil)
		}
	}
	for _, v := range m.MutedAccountsId {
		if v != nil {
			if tempMutedAccountsId, cErr := v.ToORM(ctx); cErr == nil {
				to.MutedAccountsId = append(to.MutedAccountsId, &tempMutedAccountsId)
			} else {
				return to, cErr
			}
		} else {
			to.MutedAccountsId = append(to.MutedAccountsId, nil)
		}
	}
	for _, v := range m.BlockedTeamAccountsId {
		if v != nil {
			if tempBlockedTeamAccountsId, cErr := v.ToORM(ctx); cErr == nil {
				to.BlockedTeamAccountsId = append(to.BlockedTeamAccountsId, &tempBlockedTeamAccountsId)
			} else {
				return to, cErr
			}
		} else {
			to.BlockedTeamAccountsId = append(to.BlockedTeamAccountsId, nil)
		}
	}
	for _, v := range m.MutedTeamAccountsId {
		if v != nil {
			if tempMutedTeamAccountsId, cErr := v.ToORM(ctx); cErr == nil {
				to.MutedTeamAccountsId = append(to.MutedTeamAccountsId, &tempMutedTeamAccountsId)
			} else {
				return to, cErr
			}
		} else {
			to.MutedTeamAccountsId = append(to.MutedTeamAccountsId, nil)
		}
	}
	if posthook, ok := interface{}(m).(PrivacyWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PrivacyORM) ToPB(ctx context.Context) (Privacy, error) {
	to := Privacy{}
	var err error
	if prehook, ok := interface{}(m).(PrivacyWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	to.ActivityStatus = m.ActivityStatus
	to.PrivateAccount = m.PrivateAccount
	for _, v := range m.BlockedAccountsId {
		if v != nil {
			if tempBlockedAccountsId, cErr := v.ToPB(ctx); cErr == nil {
				to.BlockedAccountsId = append(to.BlockedAccountsId, &tempBlockedAccountsId)
			} else {
				return to, cErr
			}
		} else {
			to.BlockedAccountsId = append(to.BlockedAccountsId, nil)
		}
	}
	for _, v := range m.MutedAccountsId {
		if v != nil {
			if tempMutedAccountsId, cErr := v.ToPB(ctx); cErr == nil {
				to.MutedAccountsId = append(to.MutedAccountsId, &tempMutedAccountsId)
			} else {
				return to, cErr
			}
		} else {
			to.MutedAccountsId = append(to.MutedAccountsId, nil)
		}
	}
	for _, v := range m.BlockedTeamAccountsId {
		if v != nil {
			if tempBlockedTeamAccountsId, cErr := v.ToPB(ctx); cErr == nil {
				to.BlockedTeamAccountsId = append(to.BlockedTeamAccountsId, &tempBlockedTeamAccountsId)
			} else {
				return to, cErr
			}
		} else {
			to.BlockedTeamAccountsId = append(to.BlockedTeamAccountsId, nil)
		}
	}
	for _, v := range m.MutedTeamAccountsId {
		if v != nil {
			if tempMutedTeamAccountsId, cErr := v.ToPB(ctx); cErr == nil {
				to.MutedTeamAccountsId = append(to.MutedTeamAccountsId, &tempMutedTeamAccountsId)
			} else {
				return to, cErr
			}
		} else {
			to.MutedTeamAccountsId = append(to.MutedTeamAccountsId, nil)
		}
	}
	if posthook, ok := interface{}(m).(PrivacyWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Privacy the arg will be the target, the caller the one being converted from

// PrivacyBeforeToORM called before default ToORM code
type PrivacyWithBeforeToORM interface {
	BeforeToORM(context.Context, *PrivacyORM) error
}

// PrivacyAfterToORM called after default ToORM code
type PrivacyWithAfterToORM interface {
	AfterToORM(context.Context, *PrivacyORM) error
}

// PrivacyBeforeToPB called before default ToPB code
type PrivacyWithBeforeToPB interface {
	BeforeToPB(context.Context, *Privacy) error
}

// PrivacyAfterToPB called after default ToPB code
type PrivacyWithAfterToPB interface {
	AfterToPB(context.Context, *Privacy) error
}

type NotificationORM struct {
	CreatedAt               *time.Time
	DeletedAt               *time.Time
	DirectMessagesId        *DirectMessagesPushNotificationORM        `gorm:"foreignkey:NotificationId;association_foreignkey:Id"`
	EmailAndSmsId           *EmailAndSmsPushNotificationORM           `gorm:"foreignkey:NotificationId;association_foreignkey:Id"`
	FollowingAndFollowersId *FollowingAndFollowersPushNotificationORM `gorm:"foreignkey:NotificationId;association_foreignkey:Id"`
	Id                      int32                                     `gorm:"type:integer;primary_key"`
	PauseAll                bool
	PostAndCommentsId       *PostAndCommentsPushNotificationORM `gorm:"foreignkey:NotificationId;association_foreignkey:Id"`
	SettingsId              *int32
	UpdatedAt               *time.Time
}

// TableName overrides the default tablename generated by GORM
func (NotificationORM) TableName() string {
	return "notifications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Notification) ToORM(ctx context.Context) (NotificationORM, error) {
	to := NotificationORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	to.PauseAll = m.PauseAll
	if m.PostAndCommentsId != nil {
		tempPostAndCommentsId, err := m.PostAndCommentsId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.PostAndCommentsId = &tempPostAndCommentsId
	}
	if m.FollowingAndFollowersId != nil {
		tempFollowingAndFollowersId, err := m.FollowingAndFollowersId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.FollowingAndFollowersId = &tempFollowingAndFollowersId
	}
	if m.DirectMessagesId != nil {
		tempDirectMessagesId, err := m.DirectMessagesId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.DirectMessagesId = &tempDirectMessagesId
	}
	if m.EmailAndSmsId != nil {
		tempEmailAndSmsId, err := m.EmailAndSmsId.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.EmailAndSmsId = &tempEmailAndSmsId
	}
	if posthook, ok := interface{}(m).(NotificationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationORM) ToPB(ctx context.Context) (Notification, error) {
	to := Notification{}
	var err error
	if prehook, ok := interface{}(m).(NotificationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	to.PauseAll = m.PauseAll
	if m.PostAndCommentsId != nil {
		tempPostAndCommentsId, err := m.PostAndCommentsId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.PostAndCommentsId = &tempPostAndCommentsId
	}
	if m.FollowingAndFollowersId != nil {
		tempFollowingAndFollowersId, err := m.FollowingAndFollowersId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.FollowingAndFollowersId = &tempFollowingAndFollowersId
	}
	if m.DirectMessagesId != nil {
		tempDirectMessagesId, err := m.DirectMessagesId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.DirectMessagesId = &tempDirectMessagesId
	}
	if m.EmailAndSmsId != nil {
		tempEmailAndSmsId, err := m.EmailAndSmsId.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.EmailAndSmsId = &tempEmailAndSmsId
	}
	if posthook, ok := interface{}(m).(NotificationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Notification the arg will be the target, the caller the one being converted from

// NotificationBeforeToORM called before default ToORM code
type NotificationWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationORM) error
}

// NotificationAfterToORM called after default ToORM code
type NotificationWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationORM) error
}

// NotificationBeforeToPB called before default ToPB code
type NotificationWithBeforeToPB interface {
	BeforeToPB(context.Context, *Notification) error
}

// NotificationAfterToPB called after default ToPB code
type NotificationWithAfterToPB interface {
	AfterToPB(context.Context, *Notification) error
}

type PostAndCommentsPushNotificationORM struct {
	CreatedAt      *time.Time
	DeletedAt      *time.Time
	Id             int32 `gorm:"type:integer;primary_key"`
	NotificationId *int32
	UpdatedAt      *time.Time
}

// TableName overrides the default tablename generated by GORM
func (PostAndCommentsPushNotificationORM) TableName() string {
	return "post_and_comments_push_notifications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *PostAndCommentsPushNotification) ToORM(ctx context.Context) (PostAndCommentsPushNotificationORM, error) {
	to := PostAndCommentsPushNotificationORM{}
	var err error
	if prehook, ok := interface{}(m).(PostAndCommentsPushNotificationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(PostAndCommentsPushNotificationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PostAndCommentsPushNotificationORM) ToPB(ctx context.Context) (PostAndCommentsPushNotification, error) {
	to := PostAndCommentsPushNotification{}
	var err error
	if prehook, ok := interface{}(m).(PostAndCommentsPushNotificationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if posthook, ok := interface{}(m).(PostAndCommentsPushNotificationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type PostAndCommentsPushNotification the arg will be the target, the caller the one being converted from

// PostAndCommentsPushNotificationBeforeToORM called before default ToORM code
type PostAndCommentsPushNotificationWithBeforeToORM interface {
	BeforeToORM(context.Context, *PostAndCommentsPushNotificationORM) error
}

// PostAndCommentsPushNotificationAfterToORM called after default ToORM code
type PostAndCommentsPushNotificationWithAfterToORM interface {
	AfterToORM(context.Context, *PostAndCommentsPushNotificationORM) error
}

// PostAndCommentsPushNotificationBeforeToPB called before default ToPB code
type PostAndCommentsPushNotificationWithBeforeToPB interface {
	BeforeToPB(context.Context, *PostAndCommentsPushNotification) error
}

// PostAndCommentsPushNotificationAfterToPB called after default ToPB code
type PostAndCommentsPushNotificationWithAfterToPB interface {
	AfterToPB(context.Context, *PostAndCommentsPushNotification) error
}

type FollowingAndFollowersPushNotificationORM struct {
	CreatedAt      *time.Time
	DeletedAt      *time.Time
	Id             int32 `gorm:"type:integer;primary_key"`
	NotificationId *int32
	UpdatedAt      *time.Time
}

// TableName overrides the default tablename generated by GORM
func (FollowingAndFollowersPushNotificationORM) TableName() string {
	return "following_and_followers_push_notifications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FollowingAndFollowersPushNotification) ToORM(ctx context.Context) (FollowingAndFollowersPushNotificationORM, error) {
	to := FollowingAndFollowersPushNotificationORM{}
	var err error
	if prehook, ok := interface{}(m).(FollowingAndFollowersPushNotificationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(FollowingAndFollowersPushNotificationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FollowingAndFollowersPushNotificationORM) ToPB(ctx context.Context) (FollowingAndFollowersPushNotification, error) {
	to := FollowingAndFollowersPushNotification{}
	var err error
	if prehook, ok := interface{}(m).(FollowingAndFollowersPushNotificationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if posthook, ok := interface{}(m).(FollowingAndFollowersPushNotificationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FollowingAndFollowersPushNotification the arg will be the target, the caller the one being converted from

// FollowingAndFollowersPushNotificationBeforeToORM called before default ToORM code
type FollowingAndFollowersPushNotificationWithBeforeToORM interface {
	BeforeToORM(context.Context, *FollowingAndFollowersPushNotificationORM) error
}

// FollowingAndFollowersPushNotificationAfterToORM called after default ToORM code
type FollowingAndFollowersPushNotificationWithAfterToORM interface {
	AfterToORM(context.Context, *FollowingAndFollowersPushNotificationORM) error
}

// FollowingAndFollowersPushNotificationBeforeToPB called before default ToPB code
type FollowingAndFollowersPushNotificationWithBeforeToPB interface {
	BeforeToPB(context.Context, *FollowingAndFollowersPushNotification) error
}

// FollowingAndFollowersPushNotificationAfterToPB called after default ToPB code
type FollowingAndFollowersPushNotificationWithAfterToPB interface {
	AfterToPB(context.Context, *FollowingAndFollowersPushNotification) error
}

type DirectMessagesPushNotificationORM struct {
	CreatedAt      *time.Time
	DeletedAt      *time.Time
	Id             int32 `gorm:"type:integer;primary_key"`
	NotificationId *int32
	UpdatedAt      *time.Time
}

// TableName overrides the default tablename generated by GORM
func (DirectMessagesPushNotificationORM) TableName() string {
	return "direct_messages_push_notifications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *DirectMessagesPushNotification) ToORM(ctx context.Context) (DirectMessagesPushNotificationORM, error) {
	to := DirectMessagesPushNotificationORM{}
	var err error
	if prehook, ok := interface{}(m).(DirectMessagesPushNotificationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(DirectMessagesPushNotificationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DirectMessagesPushNotificationORM) ToPB(ctx context.Context) (DirectMessagesPushNotification, error) {
	to := DirectMessagesPushNotification{}
	var err error
	if prehook, ok := interface{}(m).(DirectMessagesPushNotificationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if posthook, ok := interface{}(m).(DirectMessagesPushNotificationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type DirectMessagesPushNotification the arg will be the target, the caller the one being converted from

// DirectMessagesPushNotificationBeforeToORM called before default ToORM code
type DirectMessagesPushNotificationWithBeforeToORM interface {
	BeforeToORM(context.Context, *DirectMessagesPushNotificationORM) error
}

// DirectMessagesPushNotificationAfterToORM called after default ToORM code
type DirectMessagesPushNotificationWithAfterToORM interface {
	AfterToORM(context.Context, *DirectMessagesPushNotificationORM) error
}

// DirectMessagesPushNotificationBeforeToPB called before default ToPB code
type DirectMessagesPushNotificationWithBeforeToPB interface {
	BeforeToPB(context.Context, *DirectMessagesPushNotification) error
}

// DirectMessagesPushNotificationAfterToPB called after default ToPB code
type DirectMessagesPushNotificationWithAfterToPB interface {
	AfterToPB(context.Context, *DirectMessagesPushNotification) error
}

type EmailAndSmsPushNotificationORM struct {
	CreatedAt      *time.Time
	DeletedAt      *time.Time
	Id             int32 `gorm:"type:integer;primary_key"`
	NotificationId *int32
	UpdatedAt      *time.Time
}

// TableName overrides the default tablename generated by GORM
func (EmailAndSmsPushNotificationORM) TableName() string {
	return "email_and_sms_push_notifications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *EmailAndSmsPushNotification) ToORM(ctx context.Context) (EmailAndSmsPushNotificationORM, error) {
	to := EmailAndSmsPushNotificationORM{}
	var err error
	if prehook, ok := interface{}(m).(EmailAndSmsPushNotificationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	if m.DeletedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.DeletedAt); err != nil {
			return to, err
		}
		to.DeletedAt = &t
	}
	if posthook, ok := interface{}(m).(EmailAndSmsPushNotificationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EmailAndSmsPushNotificationORM) ToPB(ctx context.Context) (EmailAndSmsPushNotification, error) {
	to := EmailAndSmsPushNotification{}
	var err error
	if prehook, ok := interface{}(m).(EmailAndSmsPushNotificationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	if m.DeletedAt != nil {
		if to.DeletedAt, err = ptypes1.TimestampProto(*m.DeletedAt); err != nil {
			return to, err
		}
	}
	if posthook, ok := interface{}(m).(EmailAndSmsPushNotificationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type EmailAndSmsPushNotification the arg will be the target, the caller the one being converted from

// EmailAndSmsPushNotificationBeforeToORM called before default ToORM code
type EmailAndSmsPushNotificationWithBeforeToORM interface {
	BeforeToORM(context.Context, *EmailAndSmsPushNotificationORM) error
}

// EmailAndSmsPushNotificationAfterToORM called after default ToORM code
type EmailAndSmsPushNotificationWithAfterToORM interface {
	AfterToORM(context.Context, *EmailAndSmsPushNotificationORM) error
}

// EmailAndSmsPushNotificationBeforeToPB called before default ToPB code
type EmailAndSmsPushNotificationWithBeforeToPB interface {
	BeforeToPB(context.Context, *EmailAndSmsPushNotification) error
}

// EmailAndSmsPushNotificationAfterToPB called after default ToPB code
type EmailAndSmsPushNotificationWithAfterToPB interface {
	AfterToPB(context.Context, *EmailAndSmsPushNotification) error
}

// DefaultCreateUser executes a basic gorm create call
func DefaultCreateUser(ctx context.Context, in *User, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadUser executes a basic gorm read call
func DefaultReadUser(ctx context.Context, in *User, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &UserORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteUser(ctx context.Context, in *User, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteUserSet(ctx context.Context, in []*User, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*User, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*User, *gorm1.DB) error
}

// DefaultStrictUpdateUser clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUser(ctx context.Context, in *User, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &UserORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterSubscriptionsId := SubscriptionsORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterSubscriptionsId.UserId = new(int32)
	*filterSubscriptionsId.UserId = ormObj.Id
	if err = db.Where(filterSubscriptionsId).Delete(SubscriptionsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchUser executes a basic gorm update call with patch behavior
func DefaultPatchUser(ctx context.Context, in *User, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*User, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj User
	var err error
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUser(ctx, &User{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUser(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUser(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type UserWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *User, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetUser executes a bulk gorm update call with patch behavior
func DefaultPatchSetUser(ctx context.Context, objects []*User, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*User, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*User, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUser(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUser patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUser(ctx context.Context, patchee *User, patcher *User, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*User, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedProfileId bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"UserAccountType" {
			patchee.UserAccountType = patcher.UserAccountType
			continue
		}
		if f == prefix+"FirstName" {
			patchee.FirstName = patcher.FirstName
			continue
		}
		if f == prefix+"LastName" {
			patchee.LastName = patcher.LastName
			continue
		}
		if f == prefix+"UserName" {
			patchee.UserName = patcher.UserName
			continue
		}
		if f == prefix+"Gender" {
			patchee.Gender = patcher.Gender
			continue
		}
		if f == prefix+"Languages" {
			patchee.Languages = patcher.Languages
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
		if f == prefix+"PasswordConfirmed" {
			patchee.PasswordConfirmed = patcher.PasswordConfirmed
			continue
		}
		if f == prefix+"Age" {
			patchee.Age = patcher.Age
			continue
		}
		if f == prefix+"BirthDate" {
			patchee.BirthDate = patcher.BirthDate
			continue
		}
		if f == prefix+"PhoneNumber" {
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"Intent" {
			patchee.Intent = patcher.Intent
			continue
		}
		if !updatedProfileId && strings.HasPrefix(f, prefix+"ProfileId.") {
			updatedProfileId = true
			if patcher.ProfileId == nil {
				patchee.ProfileId = nil
				continue
			}
			if patchee.ProfileId == nil {
				patchee.ProfileId = &Profile{}
			}
			if o, err := DefaultApplyFieldMaskProfile(ctx, patchee.ProfileId, patcher.ProfileId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ProfileId.", db); err != nil {
				return nil, err
			} else {
				patchee.ProfileId = o
			}
			continue
		}
		if f == prefix+"ProfileId" {
			updatedProfileId = true
			patchee.ProfileId = patcher.ProfileId
			continue
		}
		if f == prefix+"ResetToken" {
			patchee.ResetToken = patcher.ResetToken
			continue
		}
		if f == prefix+"ResetTokenExpiration" {
			patchee.ResetTokenExpiration = patcher.ResetTokenExpiration
			continue
		}
		if f == prefix+"SubscriptionsId" {
			patchee.SubscriptionsId = patcher.SubscriptionsId
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUser executes a gorm list call
func DefaultListUser(ctx context.Context, db *gorm1.DB) ([]*User, error) {
	in := User{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &UserORM{}, &User{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*User{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type UserORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]UserORM) error
}

// DefaultCreateProfile executes a basic gorm create call
func DefaultCreateProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadProfile executes a basic gorm read call
func DefaultReadProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ProfileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ProfileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ProfileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ProfileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteProfile(ctx context.Context, in *Profile, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ProfileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteProfileSet(ctx context.Context, in []*Profile, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ProfileORM{})).(ProfileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ProfileORM{})).(ProfileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ProfileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Profile, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Profile, *gorm1.DB) error
}

// DefaultStrictUpdateProfile clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateProfile(ctx context.Context, in *Profile, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ProfileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterEducationId := EducationORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterEducationId.ProfileId = new(int32)
	*filterEducationId.ProfileId = ormObj.Id
	if err = db.Where(filterEducationId).Delete(EducationORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ProfileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchProfile executes a basic gorm update call with patch behavior
func DefaultPatchProfile(ctx context.Context, in *Profile, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Profile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Profile
	var err error
	if hook, ok := interface{}(&pbObj).(ProfileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadProfile(ctx, &Profile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ProfileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskProfile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ProfileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateProfile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ProfileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ProfileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Profile, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetProfile executes a bulk gorm update call with patch behavior
func DefaultPatchSetProfile(ctx context.Context, objects []*Profile, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Profile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Profile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchProfile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskProfile(ctx context.Context, patchee *Profile, patcher *Profile, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Profile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedAddressId bool
	var updatedTeamId bool
	var updatedSocialMedia bool
	var updatedSettingsId bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Bio" {
			patchee.Bio = patcher.Bio
			continue
		}
		if f == prefix+"ExperienceId" {
			patchee.ExperienceId = patcher.ExperienceId
			continue
		}
		if !updatedAddressId && strings.HasPrefix(f, prefix+"AddressId.") {
			updatedAddressId = true
			if patcher.AddressId == nil {
				patchee.AddressId = nil
				continue
			}
			if patchee.AddressId == nil {
				patchee.AddressId = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.AddressId, patcher.AddressId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"AddressId.", db); err != nil {
				return nil, err
			} else {
				patchee.AddressId = o
			}
			continue
		}
		if f == prefix+"AddressId" {
			updatedAddressId = true
			patchee.AddressId = patcher.AddressId
			continue
		}
		if f == prefix+"EducationId" {
			patchee.EducationId = patcher.EducationId
			continue
		}
		if f == prefix+"Skills" {
			patchee.Skills = patcher.Skills
			continue
		}
		if !updatedTeamId && strings.HasPrefix(f, prefix+"TeamId.") {
			updatedTeamId = true
			if patcher.TeamId == nil {
				patchee.TeamId = nil
				continue
			}
			if patchee.TeamId == nil {
				patchee.TeamId = &Team{}
			}
			if o, err := DefaultApplyFieldMaskTeam(ctx, patchee.TeamId, patcher.TeamId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"TeamId.", db); err != nil {
				return nil, err
			} else {
				patchee.TeamId = o
			}
			continue
		}
		if f == prefix+"TeamId" {
			updatedTeamId = true
			patchee.TeamId = patcher.TeamId
			continue
		}
		if f == prefix+"GroupId" {
			patchee.GroupId = patcher.GroupId
			continue
		}
		if !updatedSocialMedia && strings.HasPrefix(f, prefix+"SocialMedia.") {
			updatedSocialMedia = true
			if patcher.SocialMedia == nil {
				patchee.SocialMedia = nil
				continue
			}
			if patchee.SocialMedia == nil {
				patchee.SocialMedia = &SocialMedia{}
			}
			if o, err := DefaultApplyFieldMaskSocialMedia(ctx, patchee.SocialMedia, patcher.SocialMedia, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"SocialMedia.", db); err != nil {
				return nil, err
			} else {
				patchee.SocialMedia = o
			}
			continue
		}
		if f == prefix+"SocialMedia" {
			updatedSocialMedia = true
			patchee.SocialMedia = patcher.SocialMedia
			continue
		}
		if !updatedSettingsId && strings.HasPrefix(f, prefix+"SettingsId.") {
			updatedSettingsId = true
			if patcher.SettingsId == nil {
				patchee.SettingsId = nil
				continue
			}
			if patchee.SettingsId == nil {
				patchee.SettingsId = &Settings{}
			}
			if o, err := DefaultApplyFieldMaskSettings(ctx, patchee.SettingsId, patcher.SettingsId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"SettingsId.", db); err != nil {
				return nil, err
			} else {
				patchee.SettingsId = o
			}
			continue
		}
		if f == prefix+"SettingsId" {
			updatedSettingsId = true
			patchee.SettingsId = patcher.SettingsId
			continue
		}
		if f == prefix+"ProfileType" {
			patchee.ProfileType = patcher.ProfileType
			continue
		}
		if f == prefix+"Nationality" {
			patchee.Nationality = patcher.Nationality
			continue
		}
		if f == prefix+"AvatarUrl" {
			patchee.AvatarUrl = patcher.AvatarUrl
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListProfile executes a gorm list call
func DefaultListProfile(ctx context.Context, db *gorm1.DB) ([]*Profile, error) {
	in := Profile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ProfileORM{}, &Profile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Profile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ProfileORM) error
}

// DefaultCreateGroup executes a basic gorm create call
func DefaultCreateGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type GroupORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadGroup executes a basic gorm read call
func DefaultReadGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &GroupORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := GroupORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(GroupORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type GroupORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteGroup(ctx context.Context, in *Group, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&GroupORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type GroupORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteGroupSet(ctx context.Context, in []*Group, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&GroupORM{})).(GroupORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&GroupORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&GroupORM{})).(GroupORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type GroupORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Group, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Group, *gorm1.DB) error
}

// DefaultStrictUpdateGroup clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateGroup(ctx context.Context, in *Group, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateGroup")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &GroupORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAdmin := UserORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterAdmin.AdminGroupId = new(int32)
	*filterAdmin.AdminGroupId = ormObj.Id
	if err = db.Where(filterAdmin).Delete(UserORM{}).Error; err != nil {
		return nil, err
	}
	filterGroupMembers := UserORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterGroupMembers.GroupMembersGroupId = new(int32)
	*filterGroupMembers.GroupMembersGroupId = ormObj.Id
	if err = db.Where(filterGroupMembers).Delete(UserORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type GroupORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchGroup executes a basic gorm update call with patch behavior
func DefaultPatchGroup(ctx context.Context, in *Group, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Group, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Group
	var err error
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadGroup(ctx, &Group{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskGroup(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(GroupWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateGroup(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(GroupWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type GroupWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type GroupWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type GroupWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type GroupWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Group, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetGroup executes a bulk gorm update call with patch behavior
func DefaultPatchSetGroup(ctx context.Context, objects []*Group, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Group, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Group, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchGroup(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskGroup patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskGroup(ctx context.Context, patchee *Group, patcher *Group, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Group, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedAdmin bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Bio" {
			patchee.Bio = patcher.Bio
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"NumberOfMembers" {
			patchee.NumberOfMembers = patcher.NumberOfMembers
			continue
		}
		if f == prefix+"GroupMembers" {
			patchee.GroupMembers = patcher.GroupMembers
			continue
		}
		if f == prefix+"IsPublic" {
			patchee.IsPublic = patcher.IsPublic
			continue
		}
		if !updatedAdmin && strings.HasPrefix(f, prefix+"Admin.") {
			updatedAdmin = true
			if patcher.Admin == nil {
				patchee.Admin = nil
				continue
			}
			if patchee.Admin == nil {
				patchee.Admin = &User{}
			}
			if o, err := DefaultApplyFieldMaskUser(ctx, patchee.Admin, patcher.Admin, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Admin.", db); err != nil {
				return nil, err
			} else {
				patchee.Admin = o
			}
			continue
		}
		if f == prefix+"Admin" {
			updatedAdmin = true
			patchee.Admin = patcher.Admin
			continue
		}
		if f == prefix+"AvatarUrl" {
			patchee.AvatarUrl = patcher.AvatarUrl
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListGroup executes a gorm list call
func DefaultListGroup(ctx context.Context, db *gorm1.DB) ([]*Group, error) {
	in := Group{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &GroupORM{}, &Group{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []GroupORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(GroupORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Group{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type GroupORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type GroupORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]GroupORM) error
}

// DefaultCreateTeam executes a basic gorm create call
func DefaultCreateTeam(ctx context.Context, in *Team, db *gorm1.DB) (*Team, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TeamORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadTeam executes a basic gorm read call
func DefaultReadTeam(ctx context.Context, in *Team, db *gorm1.DB) (*Team, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &TeamORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TeamORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TeamORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TeamORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteTeam(ctx context.Context, in *Team, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TeamORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TeamORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteTeamSet(ctx context.Context, in []*Team, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TeamORM{})).(TeamORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TeamORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TeamORM{})).(TeamORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TeamORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Team, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Team, *gorm1.DB) error
}

// DefaultStrictUpdateTeam clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTeam(ctx context.Context, in *Team, db *gorm1.DB) (*Team, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTeam")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TeamORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAdminId := UserORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterAdminId.AdminIdTeamId = new(int32)
	*filterAdminId.AdminIdTeamId = ormObj.Id
	if err = db.Where(filterAdminId).Delete(UserORM{}).Error; err != nil {
		return nil, err
	}
	filterAdvisors := UserORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterAdvisors.AdvisorsTeamId = new(int32)
	*filterAdvisors.AdvisorsTeamId = ormObj.Id
	if err = db.Where(filterAdvisors).Delete(UserORM{}).Error; err != nil {
		return nil, err
	}
	filterHeadquartersId := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterHeadquartersId.TeamId = new(int32)
	*filterHeadquartersId.TeamId = ormObj.Id
	if err = db.Where(filterHeadquartersId).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterMembers := UserORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterMembers.MembersTeamId = new(int32)
	*filterMembers.MembersTeamId = ormObj.Id
	if err = db.Where(filterMembers).Delete(UserORM{}).Error; err != nil {
		return nil, err
	}
	filterSocialMedia := SocialMediaORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterSocialMedia.TeamId = new(int32)
	*filterSocialMedia.TeamId = ormObj.Id
	if err = db.Where(filterSocialMedia).Delete(SocialMediaORM{}).Error; err != nil {
		return nil, err
	}
	filterSubscriptions := SubscriptionsORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterSubscriptions.TeamId = new(int32)
	*filterSubscriptions.TeamId = ormObj.Id
	if err = db.Where(filterSubscriptions).Delete(SubscriptionsORM{}).Error; err != nil {
		return nil, err
	}
	filterTeamProfileId := TeamProfileORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterTeamProfileId.TeamId = new(int32)
	*filterTeamProfileId.TeamId = ormObj.Id
	if err = db.Where(filterTeamProfileId).Delete(TeamProfileORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TeamORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchTeam executes a basic gorm update call with patch behavior
func DefaultPatchTeam(ctx context.Context, in *Team, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Team, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Team
	var err error
	if hook, ok := interface{}(&pbObj).(TeamWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTeam(ctx, &Team{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TeamWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTeam(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TeamWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTeam(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TeamWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TeamWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Team, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TeamWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Team, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TeamWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Team, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TeamWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Team, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetTeam executes a bulk gorm update call with patch behavior
func DefaultPatchSetTeam(ctx context.Context, objects []*Team, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Team, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Team, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTeam(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTeam patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTeam(ctx context.Context, patchee *Team, patcher *Team, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Team, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedHeadquartersId bool
	var updatedSocialMedia bool
	var updatedTeamProfileId bool
	var updatedAdminId bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
		if f == prefix+"Industry" {
			patchee.Industry = patcher.Industry
			continue
		}
		if f == prefix+"FoundedDate" {
			patchee.FoundedDate = patcher.FoundedDate
			continue
		}
		if f == prefix+"NumberOfEmployees" {
			patchee.NumberOfEmployees = patcher.NumberOfEmployees
			continue
		}
		if !updatedHeadquartersId && strings.HasPrefix(f, prefix+"HeadquartersId.") {
			updatedHeadquartersId = true
			if patcher.HeadquartersId == nil {
				patchee.HeadquartersId = nil
				continue
			}
			if patchee.HeadquartersId == nil {
				patchee.HeadquartersId = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.HeadquartersId, patcher.HeadquartersId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"HeadquartersId.", db); err != nil {
				return nil, err
			} else {
				patchee.HeadquartersId = o
			}
			continue
		}
		if f == prefix+"HeadquartersId" {
			updatedHeadquartersId = true
			patchee.HeadquartersId = patcher.HeadquartersId
			continue
		}
		if f == prefix+"Members" {
			patchee.Members = patcher.Members
			continue
		}
		if f == prefix+"Advisors" {
			patchee.Advisors = patcher.Advisors
			continue
		}
		if !updatedSocialMedia && strings.HasPrefix(f, prefix+"SocialMedia.") {
			updatedSocialMedia = true
			if patcher.SocialMedia == nil {
				patchee.SocialMedia = nil
				continue
			}
			if patchee.SocialMedia == nil {
				patchee.SocialMedia = &SocialMedia{}
			}
			if o, err := DefaultApplyFieldMaskSocialMedia(ctx, patchee.SocialMedia, patcher.SocialMedia, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"SocialMedia.", db); err != nil {
				return nil, err
			} else {
				patchee.SocialMedia = o
			}
			continue
		}
		if f == prefix+"SocialMedia" {
			updatedSocialMedia = true
			patchee.SocialMedia = patcher.SocialMedia
			continue
		}
		if f == prefix+"PhoneNumber" {
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if f == prefix+"Password" {
			patchee.Password = patcher.Password
			continue
		}
		if !updatedTeamProfileId && strings.HasPrefix(f, prefix+"TeamProfileId.") {
			updatedTeamProfileId = true
			if patcher.TeamProfileId == nil {
				patchee.TeamProfileId = nil
				continue
			}
			if patchee.TeamProfileId == nil {
				patchee.TeamProfileId = &TeamProfile{}
			}
			if o, err := DefaultApplyFieldMaskTeamProfile(ctx, patchee.TeamProfileId, patcher.TeamProfileId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"TeamProfileId.", db); err != nil {
				return nil, err
			} else {
				patchee.TeamProfileId = o
			}
			continue
		}
		if f == prefix+"TeamProfileId" {
			updatedTeamProfileId = true
			patchee.TeamProfileId = patcher.TeamProfileId
			continue
		}
		if f == prefix+"Subscriptions" {
			patchee.Subscriptions = patcher.Subscriptions
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"ResetToken" {
			patchee.ResetToken = patcher.ResetToken
			continue
		}
		if f == prefix+"ResetTokenExpiration" {
			patchee.ResetTokenExpiration = patcher.ResetTokenExpiration
			continue
		}
		if !updatedAdminId && strings.HasPrefix(f, prefix+"AdminId.") {
			updatedAdminId = true
			if patcher.AdminId == nil {
				patchee.AdminId = nil
				continue
			}
			if patchee.AdminId == nil {
				patchee.AdminId = &User{}
			}
			if o, err := DefaultApplyFieldMaskUser(ctx, patchee.AdminId, patcher.AdminId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"AdminId.", db); err != nil {
				return nil, err
			} else {
				patchee.AdminId = o
			}
			continue
		}
		if f == prefix+"AdminId" {
			updatedAdminId = true
			patchee.AdminId = patcher.AdminId
			continue
		}
		if f == prefix+"Bio" {
			patchee.Bio = patcher.Bio
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTeam executes a gorm list call
func DefaultListTeam(ctx context.Context, db *gorm1.DB) ([]*Team, error) {
	in := Team{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &TeamORM{}, &Team{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TeamORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Team{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TeamORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]TeamORM) error
}

// DefaultCreateTeamProfile executes a basic gorm create call
func DefaultCreateTeamProfile(ctx context.Context, in *TeamProfile, db *gorm1.DB) (*TeamProfile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamProfileORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamProfileORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TeamProfileORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamProfileORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadTeamProfile executes a basic gorm read call
func DefaultReadTeamProfile(ctx context.Context, in *TeamProfile, db *gorm1.DB) (*TeamProfile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TeamProfileORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &TeamProfileORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamProfileORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TeamProfileORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TeamProfileORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TeamProfileORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamProfileORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamProfileORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteTeamProfile(ctx context.Context, in *TeamProfile, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TeamProfileORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TeamProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TeamProfileORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TeamProfileORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamProfileORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteTeamProfileSet(ctx context.Context, in []*TeamProfile, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TeamProfileORM{})).(TeamProfileORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TeamProfileORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TeamProfileORM{})).(TeamProfileORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TeamProfileORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*TeamProfile, *gorm1.DB) (*gorm1.DB, error)
}
type TeamProfileORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*TeamProfile, *gorm1.DB) error
}

// DefaultStrictUpdateTeamProfile clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTeamProfile(ctx context.Context, in *TeamProfile, db *gorm1.DB) (*TeamProfile, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTeamProfile")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TeamProfileORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TeamProfileORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterInvestorDetailId := InvestorDetailORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterInvestorDetailId.TeamProfileId = new(int32)
	*filterInvestorDetailId.TeamProfileId = ormObj.Id
	if err = db.Where(filterInvestorDetailId).Delete(InvestorDetailORM{}).Error; err != nil {
		return nil, err
	}
	filterMediaId := MediaORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterMediaId.TeamProfileId = new(int32)
	*filterMediaId.TeamProfileId = ormObj.Id
	if err = db.Where(filterMediaId).Delete(MediaORM{}).Error; err != nil {
		return nil, err
	}
	filterSettingsId := SettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterSettingsId.TeamProfileId = new(int32)
	*filterSettingsId.TeamProfileId = ormObj.Id
	if err = db.Where(filterSettingsId).Delete(SettingsORM{}).Error; err != nil {
		return nil, err
	}
	filterStartupDetailId := StartupDetailORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterStartupDetailId.TeamProfileId = new(int32)
	*filterStartupDetailId.TeamProfileId = ormObj.Id
	if err = db.Where(filterStartupDetailId).Delete(StartupDetailORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamProfileORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamProfileORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TeamProfileORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamProfileORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamProfileORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchTeamProfile executes a basic gorm update call with patch behavior
func DefaultPatchTeamProfile(ctx context.Context, in *TeamProfile, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*TeamProfile, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj TeamProfile
	var err error
	if hook, ok := interface{}(&pbObj).(TeamProfileWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTeamProfile(ctx, &TeamProfile{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TeamProfileWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTeamProfile(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TeamProfileWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTeamProfile(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TeamProfileWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TeamProfileWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *TeamProfile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TeamProfileWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *TeamProfile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TeamProfileWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *TeamProfile, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type TeamProfileWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *TeamProfile, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetTeamProfile executes a bulk gorm update call with patch behavior
func DefaultPatchSetTeamProfile(ctx context.Context, objects []*TeamProfile, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*TeamProfile, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*TeamProfile, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTeamProfile(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTeamProfile patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTeamProfile(ctx context.Context, patchee *TeamProfile, patcher *TeamProfile, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*TeamProfile, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedSettingsId bool
	var updatedInvestorDetailId bool
	var updatedStartupDetailId bool
	var updatedMediaId bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedSettingsId && strings.HasPrefix(f, prefix+"SettingsId.") {
			updatedSettingsId = true
			if patcher.SettingsId == nil {
				patchee.SettingsId = nil
				continue
			}
			if patchee.SettingsId == nil {
				patchee.SettingsId = &Settings{}
			}
			if o, err := DefaultApplyFieldMaskSettings(ctx, patchee.SettingsId, patcher.SettingsId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"SettingsId.", db); err != nil {
				return nil, err
			} else {
				patchee.SettingsId = o
			}
			continue
		}
		if f == prefix+"SettingsId" {
			updatedSettingsId = true
			patchee.SettingsId = patcher.SettingsId
			continue
		}
		if !updatedInvestorDetailId && strings.HasPrefix(f, prefix+"InvestorDetailId.") {
			updatedInvestorDetailId = true
			if patcher.InvestorDetailId == nil {
				patchee.InvestorDetailId = nil
				continue
			}
			if patchee.InvestorDetailId == nil {
				patchee.InvestorDetailId = &InvestorDetail{}
			}
			if o, err := DefaultApplyFieldMaskInvestorDetail(ctx, patchee.InvestorDetailId, patcher.InvestorDetailId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"InvestorDetailId.", db); err != nil {
				return nil, err
			} else {
				patchee.InvestorDetailId = o
			}
			continue
		}
		if f == prefix+"InvestorDetailId" {
			updatedInvestorDetailId = true
			patchee.InvestorDetailId = patcher.InvestorDetailId
			continue
		}
		if !updatedStartupDetailId && strings.HasPrefix(f, prefix+"StartupDetailId.") {
			updatedStartupDetailId = true
			if patcher.StartupDetailId == nil {
				patchee.StartupDetailId = nil
				continue
			}
			if patchee.StartupDetailId == nil {
				patchee.StartupDetailId = &StartupDetail{}
			}
			if o, err := DefaultApplyFieldMaskStartupDetail(ctx, patchee.StartupDetailId, patcher.StartupDetailId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"StartupDetailId.", db); err != nil {
				return nil, err
			} else {
				patchee.StartupDetailId = o
			}
			continue
		}
		if f == prefix+"StartupDetailId" {
			updatedStartupDetailId = true
			patchee.StartupDetailId = patcher.StartupDetailId
			continue
		}
		if !updatedMediaId && strings.HasPrefix(f, prefix+"MediaId.") {
			updatedMediaId = true
			if patcher.MediaId == nil {
				patchee.MediaId = nil
				continue
			}
			if patchee.MediaId == nil {
				patchee.MediaId = &Media{}
			}
			if o, err := DefaultApplyFieldMaskMedia(ctx, patchee.MediaId, patcher.MediaId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"MediaId.", db); err != nil {
				return nil, err
			} else {
				patchee.MediaId = o
			}
			continue
		}
		if f == prefix+"MediaId" {
			updatedMediaId = true
			patchee.MediaId = patcher.MediaId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTeamProfile executes a gorm list call
func DefaultListTeamProfile(ctx context.Context, db *gorm1.DB) ([]*TeamProfile, error) {
	in := TeamProfile{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamProfileORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &TeamProfileORM{}, &TeamProfile{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamProfileORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TeamProfileORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TeamProfileORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*TeamProfile{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TeamProfileORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamProfileORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type TeamProfileORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]TeamProfileORM) error
}

// DefaultCreateInvestorDetail executes a basic gorm create call
func DefaultCreateInvestorDetail(ctx context.Context, in *InvestorDetail, db *gorm1.DB) (*InvestorDetail, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorDetailORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorDetailORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvestorDetailORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorDetailORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadInvestorDetail executes a basic gorm read call
func DefaultReadInvestorDetail(ctx context.Context, in *InvestorDetail, db *gorm1.DB) (*InvestorDetail, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestorDetailORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &InvestorDetailORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorDetailORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InvestorDetailORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InvestorDetailORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InvestorDetailORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorDetailORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorDetailORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteInvestorDetail(ctx context.Context, in *InvestorDetail, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InvestorDetailORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InvestorDetailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InvestorDetailORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InvestorDetailORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorDetailORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteInvestorDetailSet(ctx context.Context, in []*InvestorDetail, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InvestorDetailORM{})).(InvestorDetailORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InvestorDetailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InvestorDetailORM{})).(InvestorDetailORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InvestorDetailORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*InvestorDetail, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorDetailORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*InvestorDetail, *gorm1.DB) error
}

// DefaultStrictUpdateInvestorDetail clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInvestorDetail(ctx context.Context, in *InvestorDetail, db *gorm1.DB) (*InvestorDetail, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInvestorDetail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InvestorDetailORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InvestorDetailORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterInvestmentsId := InvestmentORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterInvestmentsId.InvestorDetailId = new(uint32)
	*filterInvestmentsId.InvestorDetailId = ormObj.Id
	if err = db.Where(filterInvestmentsId).Delete(InvestmentORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorDetailORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorDetailORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InvestorDetailORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorDetailORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorDetailORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchInvestorDetail executes a basic gorm update call with patch behavior
func DefaultPatchInvestorDetail(ctx context.Context, in *InvestorDetail, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*InvestorDetail, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj InvestorDetail
	var err error
	if hook, ok := interface{}(&pbObj).(InvestorDetailWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInvestorDetail(ctx, &InvestorDetail{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InvestorDetailWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInvestorDetail(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InvestorDetailWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInvestorDetail(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InvestorDetailWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InvestorDetailWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *InvestorDetail, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorDetailWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *InvestorDetail, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorDetailWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *InvestorDetail, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorDetailWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *InvestorDetail, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetInvestorDetail executes a bulk gorm update call with patch behavior
func DefaultPatchSetInvestorDetail(ctx context.Context, objects []*InvestorDetail, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*InvestorDetail, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*InvestorDetail, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInvestorDetail(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInvestorDetail patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvestorDetail(ctx context.Context, patchee *InvestorDetail, patcher *InvestorDetail, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*InvestorDetail, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"InvestorType" {
			patchee.InvestorType = patcher.InvestorType
			continue
		}
		if f == prefix+"InvestmentStage" {
			patchee.InvestmentStage = patcher.InvestmentStage
			continue
		}
		if f == prefix+"NumberOfExits" {
			patchee.NumberOfExits = patcher.NumberOfExits
			continue
		}
		if f == prefix+"NumberOfInvestments" {
			patchee.NumberOfInvestments = patcher.NumberOfInvestments
			continue
		}
		if f == prefix+"NumberOfFunds" {
			patchee.NumberOfFunds = patcher.NumberOfFunds
			continue
		}
		if f == prefix+"InvestmentsId" {
			patchee.InvestmentsId = patcher.InvestmentsId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvestorDetail executes a gorm list call
func DefaultListInvestorDetail(ctx context.Context, db *gorm1.DB) ([]*InvestorDetail, error) {
	in := InvestorDetail{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorDetailORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &InvestorDetailORM{}, &InvestorDetail{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorDetailORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InvestorDetailORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestorDetailORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*InvestorDetail{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvestorDetailORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorDetailORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestorDetailORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]InvestorDetailORM) error
}

// DefaultCreateStartupDetail executes a basic gorm create call
func DefaultCreateStartupDetail(ctx context.Context, in *StartupDetail, db *gorm1.DB) (*StartupDetail, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupDetailORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupDetailORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type StartupDetailORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupDetailORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadStartupDetail executes a basic gorm read call
func DefaultReadStartupDetail(ctx context.Context, in *StartupDetail, db *gorm1.DB) (*StartupDetail, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StartupDetailORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &StartupDetailORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupDetailORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := StartupDetailORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(StartupDetailORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type StartupDetailORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupDetailORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupDetailORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteStartupDetail(ctx context.Context, in *StartupDetail, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(StartupDetailORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&StartupDetailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(StartupDetailORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type StartupDetailORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupDetailORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteStartupDetailSet(ctx context.Context, in []*StartupDetail, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&StartupDetailORM{})).(StartupDetailORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&StartupDetailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&StartupDetailORM{})).(StartupDetailORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type StartupDetailORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*StartupDetail, *gorm1.DB) (*gorm1.DB, error)
}
type StartupDetailORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*StartupDetail, *gorm1.DB) error
}

// DefaultStrictUpdateStartupDetail clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateStartupDetail(ctx context.Context, in *StartupDetail, db *gorm1.DB) (*StartupDetail, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateStartupDetail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &StartupDetailORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(StartupDetailORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(StartupDetailORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupDetailORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type StartupDetailORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupDetailORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupDetailORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchStartupDetail executes a basic gorm update call with patch behavior
func DefaultPatchStartupDetail(ctx context.Context, in *StartupDetail, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*StartupDetail, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj StartupDetail
	var err error
	if hook, ok := interface{}(&pbObj).(StartupDetailWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadStartupDetail(ctx, &StartupDetail{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(StartupDetailWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskStartupDetail(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(StartupDetailWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateStartupDetail(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(StartupDetailWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type StartupDetailWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *StartupDetail, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type StartupDetailWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *StartupDetail, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type StartupDetailWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *StartupDetail, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type StartupDetailWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *StartupDetail, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetStartupDetail executes a bulk gorm update call with patch behavior
func DefaultPatchSetStartupDetail(ctx context.Context, objects []*StartupDetail, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*StartupDetail, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*StartupDetail, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchStartupDetail(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskStartupDetail patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskStartupDetail(ctx context.Context, patchee *StartupDetail, patcher *StartupDetail, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*StartupDetail, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"TotalFunding" {
			patchee.TotalFunding = patcher.TotalFunding
			continue
		}
		if f == prefix+"LatestRoundFunding" {
			patchee.LatestRoundFunding = patcher.LatestRoundFunding
			continue
		}
		if f == prefix+"LatestRound" {
			patchee.LatestRound = patcher.LatestRound
			continue
		}
		if f == prefix+"LatestRoundEndDate" {
			patchee.LatestRoundEndDate = patcher.LatestRoundEndDate
			continue
		}
		if f == prefix+"FundingType" {
			patchee.FundingType = patcher.FundingType
			continue
		}
		if f == prefix+"CompanyName" {
			patchee.CompanyName = patcher.CompanyName
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListStartupDetail executes a gorm list call
func DefaultListStartupDetail(ctx context.Context, db *gorm1.DB) ([]*StartupDetail, error) {
	in := StartupDetail{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupDetailORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &StartupDetailORM{}, &StartupDetail{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupDetailORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []StartupDetailORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(StartupDetailORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*StartupDetail{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type StartupDetailORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupDetailORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type StartupDetailORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]StartupDetailORM) error
}

// DefaultCreateSettings executes a basic gorm create call
func DefaultCreateSettings(ctx context.Context, in *Settings, db *gorm1.DB) (*Settings, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SettingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadSettings executes a basic gorm read call
func DefaultReadSettings(ctx context.Context, in *Settings, db *gorm1.DB) (*Settings, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &SettingsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SettingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SettingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SettingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteSettings(ctx context.Context, in *Settings, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SettingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteSettingsSet(ctx context.Context, in []*Settings, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SettingsORM{})).(SettingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SettingsORM{})).(SettingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SettingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Settings, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Settings, *gorm1.DB) error
}

// DefaultStrictUpdateSettings clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSettings(ctx context.Context, in *Settings, db *gorm1.DB) (*Settings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSettings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SettingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterNotificationId := NotificationORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterNotificationId.SettingsId = new(int32)
	*filterNotificationId.SettingsId = ormObj.Id
	if err = db.Where(filterNotificationId).Delete(NotificationORM{}).Error; err != nil {
		return nil, err
	}
	filterPaymentId := PaymentsORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterPaymentId.SettingsId = new(int32)
	*filterPaymentId.SettingsId = ormObj.Id
	if err = db.Where(filterPaymentId).Delete(PaymentsORM{}).Error; err != nil {
		return nil, err
	}
	filterPrivacyId := PrivacyORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterPrivacyId.SettingsId = new(int32)
	*filterPrivacyId.SettingsId = ormObj.Id
	if err = db.Where(filterPrivacyId).Delete(PrivacyORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SettingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchSettings executes a basic gorm update call with patch behavior
func DefaultPatchSettings(ctx context.Context, in *Settings, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Settings, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Settings
	var err error
	if hook, ok := interface{}(&pbObj).(SettingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSettings(ctx, &Settings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SettingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSettings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SettingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSettings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SettingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SettingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Settings, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Settings, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Settings, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Settings, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetSettings executes a bulk gorm update call with patch behavior
func DefaultPatchSetSettings(ctx context.Context, objects []*Settings, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Settings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Settings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSettings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSettings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSettings(ctx context.Context, patchee *Settings, patcher *Settings, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Settings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedNotificationId bool
	var updatedPrivacyId bool
	var updatedPaymentId bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"LastLogin" {
			patchee.LastLogin = patcher.LastLogin
			continue
		}
		if f == prefix+"LastLoginLocation" {
			patchee.LastLoginLocation = patcher.LastLoginLocation
			continue
		}
		if !updatedNotificationId && strings.HasPrefix(f, prefix+"NotificationId.") {
			updatedNotificationId = true
			if patcher.NotificationId == nil {
				patchee.NotificationId = nil
				continue
			}
			if patchee.NotificationId == nil {
				patchee.NotificationId = &Notification{}
			}
			if o, err := DefaultApplyFieldMaskNotification(ctx, patchee.NotificationId, patcher.NotificationId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"NotificationId.", db); err != nil {
				return nil, err
			} else {
				patchee.NotificationId = o
			}
			continue
		}
		if f == prefix+"NotificationId" {
			updatedNotificationId = true
			patchee.NotificationId = patcher.NotificationId
			continue
		}
		if !updatedPrivacyId && strings.HasPrefix(f, prefix+"PrivacyId.") {
			updatedPrivacyId = true
			if patcher.PrivacyId == nil {
				patchee.PrivacyId = nil
				continue
			}
			if patchee.PrivacyId == nil {
				patchee.PrivacyId = &Privacy{}
			}
			if o, err := DefaultApplyFieldMaskPrivacy(ctx, patchee.PrivacyId, patcher.PrivacyId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"PrivacyId.", db); err != nil {
				return nil, err
			} else {
				patchee.PrivacyId = o
			}
			continue
		}
		if f == prefix+"PrivacyId" {
			updatedPrivacyId = true
			patchee.PrivacyId = patcher.PrivacyId
			continue
		}
		if !updatedPaymentId && strings.HasPrefix(f, prefix+"PaymentId.") {
			updatedPaymentId = true
			if patcher.PaymentId == nil {
				patchee.PaymentId = nil
				continue
			}
			if patchee.PaymentId == nil {
				patchee.PaymentId = &Payments{}
			}
			if o, err := DefaultApplyFieldMaskPayments(ctx, patchee.PaymentId, patcher.PaymentId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"PaymentId.", db); err != nil {
				return nil, err
			} else {
				patchee.PaymentId = o
			}
			continue
		}
		if f == prefix+"PaymentId" {
			updatedPaymentId = true
			patchee.PaymentId = patcher.PaymentId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSettings executes a gorm list call
func DefaultListSettings(ctx context.Context, db *gorm1.DB) ([]*Settings, error) {
	in := Settings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &SettingsORM{}, &Settings{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SettingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Settings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SettingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]SettingsORM) error
}

// DefaultCreateLoginActivity executes a basic gorm create call
func DefaultCreateLoginActivity(ctx context.Context, in *LoginActivity, db *gorm1.DB) (*LoginActivity, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LoginActivityORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadLoginActivity executes a basic gorm read call
func DefaultReadLoginActivity(ctx context.Context, in *LoginActivity, db *gorm1.DB) (*LoginActivity, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &LoginActivityORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LoginActivityORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LoginActivityORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LoginActivityORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteLoginActivity(ctx context.Context, in *LoginActivity, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LoginActivityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LoginActivityORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteLoginActivitySet(ctx context.Context, in []*LoginActivity, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LoginActivityORM{})).(LoginActivityORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LoginActivityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LoginActivityORM{})).(LoginActivityORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LoginActivityORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*LoginActivity, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*LoginActivity, *gorm1.DB) error
}

// DefaultStrictUpdateLoginActivity clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLoginActivity(ctx context.Context, in *LoginActivity, db *gorm1.DB) (*LoginActivity, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLoginActivity")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LoginActivityORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLocation := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterLocation.LoginActivityId = new(int32)
	*filterLocation.LoginActivityId = ormObj.Id
	if err = db.Where(filterLocation).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LoginActivityORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchLoginActivity executes a basic gorm update call with patch behavior
func DefaultPatchLoginActivity(ctx context.Context, in *LoginActivity, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*LoginActivity, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj LoginActivity
	var err error
	if hook, ok := interface{}(&pbObj).(LoginActivityWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLoginActivity(ctx, &LoginActivity{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LoginActivityWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLoginActivity(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LoginActivityWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLoginActivity(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LoginActivityWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LoginActivityWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *LoginActivity, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *LoginActivity, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *LoginActivity, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *LoginActivity, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetLoginActivity executes a bulk gorm update call with patch behavior
func DefaultPatchSetLoginActivity(ctx context.Context, objects []*LoginActivity, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*LoginActivity, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*LoginActivity, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLoginActivity(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLoginActivity patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLoginActivity(ctx context.Context, patchee *LoginActivity, patcher *LoginActivity, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*LoginActivity, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedLocation bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedLocation && strings.HasPrefix(f, prefix+"Location.") {
			updatedLocation = true
			if patcher.Location == nil {
				patchee.Location = nil
				continue
			}
			if patchee.Location == nil {
				patchee.Location = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.Location, patcher.Location, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Location.", db); err != nil {
				return nil, err
			} else {
				patchee.Location = o
			}
			continue
		}
		if f == prefix+"Location" {
			updatedLocation = true
			patchee.Location = patcher.Location
			continue
		}
		if f == prefix+"Date" {
			patchee.Date = patcher.Date
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLoginActivity executes a gorm list call
func DefaultListLoginActivity(ctx context.Context, db *gorm1.DB) ([]*LoginActivity, error) {
	in := LoginActivity{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &LoginActivityORM{}, &LoginActivity{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LoginActivityORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LoginActivity{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LoginActivityORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]LoginActivityORM) error
}

// DefaultCreatePayments executes a basic gorm create call
func DefaultCreatePayments(ctx context.Context, in *Payments, db *gorm1.DB) (*Payments, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PaymentsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PaymentsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadPayments executes a basic gorm read call
func DefaultReadPayments(ctx context.Context, in *Payments, db *gorm1.DB) (*Payments, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PaymentsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &PaymentsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PaymentsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PaymentsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PaymentsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PaymentsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PaymentsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeletePayments(ctx context.Context, in *Payments, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PaymentsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PaymentsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PaymentsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PaymentsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PaymentsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeletePaymentsSet(ctx context.Context, in []*Payments, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PaymentsORM{})).(PaymentsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PaymentsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PaymentsORM{})).(PaymentsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PaymentsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Payments, *gorm1.DB) (*gorm1.DB, error)
}
type PaymentsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Payments, *gorm1.DB) error
}

// DefaultStrictUpdatePayments clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePayments(ctx context.Context, in *Payments, db *gorm1.DB) (*Payments, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePayments")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PaymentsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PaymentsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCreditCard := CardORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterCreditCard.CreditCardPaymentsId = new(int32)
	*filterCreditCard.CreditCardPaymentsId = ormObj.Id
	if err = db.Where(filterCreditCard).Delete(CardORM{}).Error; err != nil {
		return nil, err
	}
	filterDebitCard := CardORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterDebitCard.DebitCardPaymentsId = new(int32)
	*filterDebitCard.DebitCardPaymentsId = ormObj.Id
	if err = db.Where(filterDebitCard).Delete(CardORM{}).Error; err != nil {
		return nil, err
	}
	filterPin := PinORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterPin.PaymentsId = new(int32)
	*filterPin.PaymentsId = ormObj.Id
	if err = db.Where(filterPin).Delete(PinORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PaymentsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PaymentsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PaymentsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchPayments executes a basic gorm update call with patch behavior
func DefaultPatchPayments(ctx context.Context, in *Payments, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Payments, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Payments
	var err error
	if hook, ok := interface{}(&pbObj).(PaymentsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPayments(ctx, &Payments{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PaymentsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPayments(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PaymentsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePayments(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PaymentsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PaymentsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Payments, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PaymentsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Payments, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PaymentsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Payments, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PaymentsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Payments, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetPayments executes a bulk gorm update call with patch behavior
func DefaultPatchSetPayments(ctx context.Context, objects []*Payments, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Payments, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Payments, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPayments(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPayments patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPayments(ctx context.Context, patchee *Payments, patcher *Payments, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Payments, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedDebitCard bool
	var updatedCreditCard bool
	var updatedPin bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"LastLogin" {
			patchee.LastLogin = patcher.LastLogin
			continue
		}
		if !updatedDebitCard && strings.HasPrefix(f, prefix+"DebitCard.") {
			updatedDebitCard = true
			if patcher.DebitCard == nil {
				patchee.DebitCard = nil
				continue
			}
			if patchee.DebitCard == nil {
				patchee.DebitCard = &Card{}
			}
			if o, err := DefaultApplyFieldMaskCard(ctx, patchee.DebitCard, patcher.DebitCard, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"DebitCard.", db); err != nil {
				return nil, err
			} else {
				patchee.DebitCard = o
			}
			continue
		}
		if f == prefix+"DebitCard" {
			updatedDebitCard = true
			patchee.DebitCard = patcher.DebitCard
			continue
		}
		if !updatedCreditCard && strings.HasPrefix(f, prefix+"CreditCard.") {
			updatedCreditCard = true
			if patcher.CreditCard == nil {
				patchee.CreditCard = nil
				continue
			}
			if patchee.CreditCard == nil {
				patchee.CreditCard = &Card{}
			}
			if o, err := DefaultApplyFieldMaskCard(ctx, patchee.CreditCard, patcher.CreditCard, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"CreditCard.", db); err != nil {
				return nil, err
			} else {
				patchee.CreditCard = o
			}
			continue
		}
		if f == prefix+"CreditCard" {
			updatedCreditCard = true
			patchee.CreditCard = patcher.CreditCard
			continue
		}
		if !updatedPin && strings.HasPrefix(f, prefix+"Pin.") {
			updatedPin = true
			if patcher.Pin == nil {
				patchee.Pin = nil
				continue
			}
			if patchee.Pin == nil {
				patchee.Pin = &Pin{}
			}
			if o, err := DefaultApplyFieldMaskPin(ctx, patchee.Pin, patcher.Pin, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Pin.", db); err != nil {
				return nil, err
			} else {
				patchee.Pin = o
			}
			continue
		}
		if f == prefix+"Pin" {
			updatedPin = true
			patchee.Pin = patcher.Pin
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPayments executes a gorm list call
func DefaultListPayments(ctx context.Context, db *gorm1.DB) ([]*Payments, error) {
	in := Payments{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &PaymentsORM{}, &Payments{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PaymentsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Payments{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PaymentsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PaymentsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PaymentsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]PaymentsORM) error
}

// DefaultCreateCard executes a basic gorm create call
func DefaultCreateCard(ctx context.Context, in *Card, db *gorm1.DB) (*Card, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CardORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CardORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadCard executes a basic gorm read call
func DefaultReadCard(ctx context.Context, in *Card, db *gorm1.DB) (*Card, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &CardORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CardORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CardORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CardORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CardORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CardORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteCard(ctx context.Context, in *Card, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CardORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CardORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CardORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteCardSet(ctx context.Context, in []*Card, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CardORM{})).(CardORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CardORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CardORM{})).(CardORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CardORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Card, *gorm1.DB) (*gorm1.DB, error)
}
type CardORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Card, *gorm1.DB) error
}

// DefaultStrictUpdateCard clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCard(ctx context.Context, in *Card, db *gorm1.DB) (*Card, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCard")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CardORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CardORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CardORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CardORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CardORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchCard executes a basic gorm update call with patch behavior
func DefaultPatchCard(ctx context.Context, in *Card, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Card, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Card
	var err error
	if hook, ok := interface{}(&pbObj).(CardWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCard(ctx, &Card{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CardWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCard(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CardWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCard(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CardWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CardWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Card, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CardWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Card, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CardWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Card, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CardWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Card, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetCard executes a bulk gorm update call with patch behavior
func DefaultPatchSetCard(ctx context.Context, objects []*Card, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Card, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Card, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCard(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCard patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCard(ctx context.Context, patchee *Card, patcher *Card, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Card, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"LastLogin" {
			patchee.LastLogin = patcher.LastLogin
			continue
		}
		if f == prefix+"CardNumber" {
			patchee.CardNumber = patcher.CardNumber
			continue
		}
		if f == prefix+"SecurityCode" {
			patchee.SecurityCode = patcher.SecurityCode
			continue
		}
		if f == prefix+"CardZipCode" {
			patchee.CardZipCode = patcher.CardZipCode
			continue
		}
		if f == prefix+"FullName" {
			patchee.FullName = patcher.FullName
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Zipcode" {
			patchee.Zipcode = patcher.Zipcode
			continue
		}
		if f == prefix+"Address" {
			patchee.Address = patcher.Address
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCard executes a gorm list call
func DefaultListCard(ctx context.Context, db *gorm1.DB) ([]*Card, error) {
	in := Card{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &CardORM{}, &Card{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CardORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Card{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CardORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CardORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CardORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]CardORM) error
}

// DefaultCreatePin executes a basic gorm create call
func DefaultCreatePin(ctx context.Context, in *Pin, db *gorm1.DB) (*Pin, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PinORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PinORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PinORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PinORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadPin executes a basic gorm read call
func DefaultReadPin(ctx context.Context, in *Pin, db *gorm1.DB) (*Pin, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PinORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &PinORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PinORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PinORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PinORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PinORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PinORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PinORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeletePin(ctx context.Context, in *Pin, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PinORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PinORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PinORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PinORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PinORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeletePinSet(ctx context.Context, in []*Pin, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PinORM{})).(PinORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PinORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PinORM{})).(PinORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PinORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Pin, *gorm1.DB) (*gorm1.DB, error)
}
type PinORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Pin, *gorm1.DB) error
}

// DefaultStrictUpdatePin clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePin(ctx context.Context, in *Pin, db *gorm1.DB) (*Pin, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePin")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PinORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PinORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PinORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PinORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PinORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PinORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PinORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchPin executes a basic gorm update call with patch behavior
func DefaultPatchPin(ctx context.Context, in *Pin, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Pin, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Pin
	var err error
	if hook, ok := interface{}(&pbObj).(PinWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPin(ctx, &Pin{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PinWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPin(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PinWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePin(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PinWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PinWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Pin, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PinWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Pin, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PinWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Pin, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PinWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Pin, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetPin executes a bulk gorm update call with patch behavior
func DefaultPatchSetPin(ctx context.Context, objects []*Pin, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Pin, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Pin, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPin(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPin patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPin(ctx context.Context, patchee *Pin, patcher *Pin, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Pin, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"LastLogin" {
			patchee.LastLogin = patcher.LastLogin
			continue
		}
		if f == prefix+"PinEnabled" {
			patchee.PinEnabled = patcher.PinEnabled
			continue
		}
		if f == prefix+"Pin" {
			patchee.Pin = patcher.Pin
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPin executes a gorm list call
func DefaultListPin(ctx context.Context, db *gorm1.DB) ([]*Pin, error) {
	in := Pin{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PinORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &PinORM{}, &Pin{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PinORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PinORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PinORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Pin{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PinORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PinORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PinORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]PinORM) error
}

// DefaultCreatePrivacy executes a basic gorm create call
func DefaultCreatePrivacy(ctx context.Context, in *Privacy, db *gorm1.DB) (*Privacy, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrivacyORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrivacyORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PrivacyORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PrivacyORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadPrivacy executes a basic gorm read call
func DefaultReadPrivacy(ctx context.Context, in *Privacy, db *gorm1.DB) (*Privacy, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PrivacyORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &PrivacyORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrivacyORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PrivacyORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PrivacyORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PrivacyORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PrivacyORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PrivacyORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeletePrivacy(ctx context.Context, in *Privacy, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PrivacyORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PrivacyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PrivacyORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PrivacyORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PrivacyORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeletePrivacySet(ctx context.Context, in []*Privacy, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PrivacyORM{})).(PrivacyORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PrivacyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PrivacyORM{})).(PrivacyORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PrivacyORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Privacy, *gorm1.DB) (*gorm1.DB, error)
}
type PrivacyORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Privacy, *gorm1.DB) error
}

// DefaultStrictUpdatePrivacy clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePrivacy(ctx context.Context, in *Privacy, db *gorm1.DB) (*Privacy, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePrivacy")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PrivacyORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PrivacyORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterBlockedAccountsId := ProfileORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterBlockedAccountsId.BlockedAccountsIdPrivacyId = new(int32)
	*filterBlockedAccountsId.BlockedAccountsIdPrivacyId = ormObj.Id
	if err = db.Where(filterBlockedAccountsId).Delete(ProfileORM{}).Error; err != nil {
		return nil, err
	}
	filterBlockedTeamAccountsId := TeamProfileORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterBlockedTeamAccountsId.BlockedTeamAccountsIdPrivacyId = new(int32)
	*filterBlockedTeamAccountsId.BlockedTeamAccountsIdPrivacyId = ormObj.Id
	if err = db.Where(filterBlockedTeamAccountsId).Delete(TeamProfileORM{}).Error; err != nil {
		return nil, err
	}
	filterMutedAccountsId := ProfileORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterMutedAccountsId.MutedAccountsIdPrivacyId = new(int32)
	*filterMutedAccountsId.MutedAccountsIdPrivacyId = ormObj.Id
	if err = db.Where(filterMutedAccountsId).Delete(ProfileORM{}).Error; err != nil {
		return nil, err
	}
	filterMutedTeamAccountsId := TeamProfileORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterMutedTeamAccountsId.MutedTeamAccountsIdPrivacyId = new(int32)
	*filterMutedTeamAccountsId.MutedTeamAccountsIdPrivacyId = ormObj.Id
	if err = db.Where(filterMutedTeamAccountsId).Delete(TeamProfileORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrivacyORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrivacyORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PrivacyORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PrivacyORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PrivacyORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchPrivacy executes a basic gorm update call with patch behavior
func DefaultPatchPrivacy(ctx context.Context, in *Privacy, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Privacy, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Privacy
	var err error
	if hook, ok := interface{}(&pbObj).(PrivacyWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPrivacy(ctx, &Privacy{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PrivacyWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPrivacy(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PrivacyWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePrivacy(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PrivacyWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PrivacyWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Privacy, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PrivacyWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Privacy, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PrivacyWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Privacy, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PrivacyWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Privacy, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetPrivacy executes a bulk gorm update call with patch behavior
func DefaultPatchSetPrivacy(ctx context.Context, objects []*Privacy, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Privacy, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Privacy, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPrivacy(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPrivacy patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPrivacy(ctx context.Context, patchee *Privacy, patcher *Privacy, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Privacy, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"ActivityStatus" {
			patchee.ActivityStatus = patcher.ActivityStatus
			continue
		}
		if f == prefix+"PrivateAccount" {
			patchee.PrivateAccount = patcher.PrivateAccount
			continue
		}
		if f == prefix+"BlockedAccountsId" {
			patchee.BlockedAccountsId = patcher.BlockedAccountsId
			continue
		}
		if f == prefix+"MutedAccountsId" {
			patchee.MutedAccountsId = patcher.MutedAccountsId
			continue
		}
		if f == prefix+"BlockedTeamAccountsId" {
			patchee.BlockedTeamAccountsId = patcher.BlockedTeamAccountsId
			continue
		}
		if f == prefix+"MutedTeamAccountsId" {
			patchee.MutedTeamAccountsId = patcher.MutedTeamAccountsId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPrivacy executes a gorm list call
func DefaultListPrivacy(ctx context.Context, db *gorm1.DB) ([]*Privacy, error) {
	in := Privacy{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrivacyORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &PrivacyORM{}, &Privacy{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrivacyORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PrivacyORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PrivacyORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Privacy{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PrivacyORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PrivacyORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PrivacyORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]PrivacyORM) error
}

// DefaultCreateNotification executes a basic gorm create call
func DefaultCreateNotification(ctx context.Context, in *Notification, db *gorm1.DB) (*Notification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadNotification executes a basic gorm read call
func DefaultReadNotification(ctx context.Context, in *Notification, db *gorm1.DB) (*Notification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &NotificationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteNotification(ctx context.Context, in *Notification, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteNotificationSet(ctx context.Context, in []*Notification, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NotificationORM{})).(NotificationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&NotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationORM{})).(NotificationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Notification, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Notification, *gorm1.DB) error
}

// DefaultStrictUpdateNotification clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotification(ctx context.Context, in *Notification, db *gorm1.DB) (*Notification, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotification")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterDirectMessagesId := DirectMessagesPushNotificationORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterDirectMessagesId.NotificationId = new(int32)
	*filterDirectMessagesId.NotificationId = ormObj.Id
	if err = db.Where(filterDirectMessagesId).Delete(DirectMessagesPushNotificationORM{}).Error; err != nil {
		return nil, err
	}
	filterEmailAndSmsId := EmailAndSmsPushNotificationORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterEmailAndSmsId.NotificationId = new(int32)
	*filterEmailAndSmsId.NotificationId = ormObj.Id
	if err = db.Where(filterEmailAndSmsId).Delete(EmailAndSmsPushNotificationORM{}).Error; err != nil {
		return nil, err
	}
	filterFollowingAndFollowersId := FollowingAndFollowersPushNotificationORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterFollowingAndFollowersId.NotificationId = new(int32)
	*filterFollowingAndFollowersId.NotificationId = ormObj.Id
	if err = db.Where(filterFollowingAndFollowersId).Delete(FollowingAndFollowersPushNotificationORM{}).Error; err != nil {
		return nil, err
	}
	filterPostAndCommentsId := PostAndCommentsPushNotificationORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterPostAndCommentsId.NotificationId = new(int32)
	*filterPostAndCommentsId.NotificationId = ormObj.Id
	if err = db.Where(filterPostAndCommentsId).Delete(PostAndCommentsPushNotificationORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchNotification executes a basic gorm update call with patch behavior
func DefaultPatchNotification(ctx context.Context, in *Notification, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Notification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Notification
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNotification(ctx, &Notification{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NotificationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotification(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotification(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Notification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Notification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Notification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Notification, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetNotification executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotification(ctx context.Context, objects []*Notification, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Notification, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Notification, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotification(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotification patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotification(ctx context.Context, patchee *Notification, patcher *Notification, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Notification, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedPostAndCommentsId bool
	var updatedFollowingAndFollowersId bool
	var updatedDirectMessagesId bool
	var updatedEmailAndSmsId bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if f == prefix+"PauseAll" {
			patchee.PauseAll = patcher.PauseAll
			continue
		}
		if !updatedPostAndCommentsId && strings.HasPrefix(f, prefix+"PostAndCommentsId.") {
			updatedPostAndCommentsId = true
			if patcher.PostAndCommentsId == nil {
				patchee.PostAndCommentsId = nil
				continue
			}
			if patchee.PostAndCommentsId == nil {
				patchee.PostAndCommentsId = &PostAndCommentsPushNotification{}
			}
			if o, err := DefaultApplyFieldMaskPostAndCommentsPushNotification(ctx, patchee.PostAndCommentsId, patcher.PostAndCommentsId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"PostAndCommentsId.", db); err != nil {
				return nil, err
			} else {
				patchee.PostAndCommentsId = o
			}
			continue
		}
		if f == prefix+"PostAndCommentsId" {
			updatedPostAndCommentsId = true
			patchee.PostAndCommentsId = patcher.PostAndCommentsId
			continue
		}
		if !updatedFollowingAndFollowersId && strings.HasPrefix(f, prefix+"FollowingAndFollowersId.") {
			updatedFollowingAndFollowersId = true
			if patcher.FollowingAndFollowersId == nil {
				patchee.FollowingAndFollowersId = nil
				continue
			}
			if patchee.FollowingAndFollowersId == nil {
				patchee.FollowingAndFollowersId = &FollowingAndFollowersPushNotification{}
			}
			if o, err := DefaultApplyFieldMaskFollowingAndFollowersPushNotification(ctx, patchee.FollowingAndFollowersId, patcher.FollowingAndFollowersId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"FollowingAndFollowersId.", db); err != nil {
				return nil, err
			} else {
				patchee.FollowingAndFollowersId = o
			}
			continue
		}
		if f == prefix+"FollowingAndFollowersId" {
			updatedFollowingAndFollowersId = true
			patchee.FollowingAndFollowersId = patcher.FollowingAndFollowersId
			continue
		}
		if !updatedDirectMessagesId && strings.HasPrefix(f, prefix+"DirectMessagesId.") {
			updatedDirectMessagesId = true
			if patcher.DirectMessagesId == nil {
				patchee.DirectMessagesId = nil
				continue
			}
			if patchee.DirectMessagesId == nil {
				patchee.DirectMessagesId = &DirectMessagesPushNotification{}
			}
			if o, err := DefaultApplyFieldMaskDirectMessagesPushNotification(ctx, patchee.DirectMessagesId, patcher.DirectMessagesId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"DirectMessagesId.", db); err != nil {
				return nil, err
			} else {
				patchee.DirectMessagesId = o
			}
			continue
		}
		if f == prefix+"DirectMessagesId" {
			updatedDirectMessagesId = true
			patchee.DirectMessagesId = patcher.DirectMessagesId
			continue
		}
		if !updatedEmailAndSmsId && strings.HasPrefix(f, prefix+"EmailAndSmsId.") {
			updatedEmailAndSmsId = true
			if patcher.EmailAndSmsId == nil {
				patchee.EmailAndSmsId = nil
				continue
			}
			if patchee.EmailAndSmsId == nil {
				patchee.EmailAndSmsId = &EmailAndSmsPushNotification{}
			}
			if o, err := DefaultApplyFieldMaskEmailAndSmsPushNotification(ctx, patchee.EmailAndSmsId, patcher.EmailAndSmsId, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"EmailAndSmsId.", db); err != nil {
				return nil, err
			} else {
				patchee.EmailAndSmsId = o
			}
			continue
		}
		if f == prefix+"EmailAndSmsId" {
			updatedEmailAndSmsId = true
			patchee.EmailAndSmsId = patcher.EmailAndSmsId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotification executes a gorm list call
func DefaultListNotification(ctx context.Context, db *gorm1.DB) ([]*Notification, error) {
	in := Notification{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &NotificationORM{}, &Notification{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NotificationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Notification{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]NotificationORM) error
}

// DefaultCreatePostAndCommentsPushNotification executes a basic gorm create call
func DefaultCreatePostAndCommentsPushNotification(ctx context.Context, in *PostAndCommentsPushNotification, db *gorm1.DB) (*PostAndCommentsPushNotification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PostAndCommentsPushNotificationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PostAndCommentsPushNotificationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PostAndCommentsPushNotificationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PostAndCommentsPushNotificationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadPostAndCommentsPushNotification executes a basic gorm read call
func DefaultReadPostAndCommentsPushNotification(ctx context.Context, in *PostAndCommentsPushNotification, db *gorm1.DB) (*PostAndCommentsPushNotification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PostAndCommentsPushNotificationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &PostAndCommentsPushNotificationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PostAndCommentsPushNotificationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PostAndCommentsPushNotificationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PostAndCommentsPushNotificationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PostAndCommentsPushNotificationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PostAndCommentsPushNotificationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PostAndCommentsPushNotificationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeletePostAndCommentsPushNotification(ctx context.Context, in *PostAndCommentsPushNotification, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PostAndCommentsPushNotificationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PostAndCommentsPushNotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PostAndCommentsPushNotificationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PostAndCommentsPushNotificationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PostAndCommentsPushNotificationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeletePostAndCommentsPushNotificationSet(ctx context.Context, in []*PostAndCommentsPushNotification, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PostAndCommentsPushNotificationORM{})).(PostAndCommentsPushNotificationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PostAndCommentsPushNotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PostAndCommentsPushNotificationORM{})).(PostAndCommentsPushNotificationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PostAndCommentsPushNotificationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*PostAndCommentsPushNotification, *gorm1.DB) (*gorm1.DB, error)
}
type PostAndCommentsPushNotificationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*PostAndCommentsPushNotification, *gorm1.DB) error
}

// DefaultStrictUpdatePostAndCommentsPushNotification clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePostAndCommentsPushNotification(ctx context.Context, in *PostAndCommentsPushNotification, db *gorm1.DB) (*PostAndCommentsPushNotification, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePostAndCommentsPushNotification")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PostAndCommentsPushNotificationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PostAndCommentsPushNotificationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PostAndCommentsPushNotificationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PostAndCommentsPushNotificationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PostAndCommentsPushNotificationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PostAndCommentsPushNotificationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PostAndCommentsPushNotificationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchPostAndCommentsPushNotification executes a basic gorm update call with patch behavior
func DefaultPatchPostAndCommentsPushNotification(ctx context.Context, in *PostAndCommentsPushNotification, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*PostAndCommentsPushNotification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj PostAndCommentsPushNotification
	var err error
	if hook, ok := interface{}(&pbObj).(PostAndCommentsPushNotificationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPostAndCommentsPushNotification(ctx, &PostAndCommentsPushNotification{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PostAndCommentsPushNotificationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPostAndCommentsPushNotification(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PostAndCommentsPushNotificationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePostAndCommentsPushNotification(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PostAndCommentsPushNotificationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PostAndCommentsPushNotificationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *PostAndCommentsPushNotification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PostAndCommentsPushNotificationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *PostAndCommentsPushNotification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PostAndCommentsPushNotificationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *PostAndCommentsPushNotification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PostAndCommentsPushNotificationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *PostAndCommentsPushNotification, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetPostAndCommentsPushNotification executes a bulk gorm update call with patch behavior
func DefaultPatchSetPostAndCommentsPushNotification(ctx context.Context, objects []*PostAndCommentsPushNotification, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*PostAndCommentsPushNotification, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*PostAndCommentsPushNotification, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPostAndCommentsPushNotification(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPostAndCommentsPushNotification patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPostAndCommentsPushNotification(ctx context.Context, patchee *PostAndCommentsPushNotification, patcher *PostAndCommentsPushNotification, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*PostAndCommentsPushNotification, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedLikes bool
	var updatedLikesAndCommentsOnPostsOfYou bool
	var updatedPostsOfYou bool
	var updatedComments bool
	var updatedCommentLikes bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if !updatedLikes && strings.HasPrefix(f, prefix+"Likes.") {
			if patcher.Likes == nil {
				patchee.Likes = nil
				continue
			}
			if patchee.Likes == nil {
				patchee.Likes = &TieredPushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Likes."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.Likes, patchee.Likes, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Likes" {
			updatedLikes = true
			patchee.Likes = patcher.Likes
			continue
		}
		if !updatedLikesAndCommentsOnPostsOfYou && strings.HasPrefix(f, prefix+"LikesAndCommentsOnPostsOfYou.") {
			if patcher.LikesAndCommentsOnPostsOfYou == nil {
				patchee.LikesAndCommentsOnPostsOfYou = nil
				continue
			}
			if patchee.LikesAndCommentsOnPostsOfYou == nil {
				patchee.LikesAndCommentsOnPostsOfYou = &TieredPushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"LikesAndCommentsOnPostsOfYou."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.LikesAndCommentsOnPostsOfYou, patchee.LikesAndCommentsOnPostsOfYou, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"LikesAndCommentsOnPostsOfYou" {
			updatedLikesAndCommentsOnPostsOfYou = true
			patchee.LikesAndCommentsOnPostsOfYou = patcher.LikesAndCommentsOnPostsOfYou
			continue
		}
		if !updatedPostsOfYou && strings.HasPrefix(f, prefix+"PostsOfYou.") {
			if patcher.PostsOfYou == nil {
				patchee.PostsOfYou = nil
				continue
			}
			if patchee.PostsOfYou == nil {
				patchee.PostsOfYou = &TieredPushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"PostsOfYou."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.PostsOfYou, patchee.PostsOfYou, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"PostsOfYou" {
			updatedPostsOfYou = true
			patchee.PostsOfYou = patcher.PostsOfYou
			continue
		}
		if !updatedComments && strings.HasPrefix(f, prefix+"Comments.") {
			if patcher.Comments == nil {
				patchee.Comments = nil
				continue
			}
			if patchee.Comments == nil {
				patchee.Comments = &TieredPushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Comments."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.Comments, patchee.Comments, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Comments" {
			updatedComments = true
			patchee.Comments = patcher.Comments
			continue
		}
		if !updatedCommentLikes && strings.HasPrefix(f, prefix+"CommentLikes.") {
			if patcher.CommentLikes == nil {
				patchee.CommentLikes = nil
				continue
			}
			if patchee.CommentLikes == nil {
				patchee.CommentLikes = &TieredPushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CommentLikes."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.CommentLikes, patchee.CommentLikes, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CommentLikes" {
			updatedCommentLikes = true
			patchee.CommentLikes = patcher.CommentLikes
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPostAndCommentsPushNotification executes a gorm list call
func DefaultListPostAndCommentsPushNotification(ctx context.Context, db *gorm1.DB) ([]*PostAndCommentsPushNotification, error) {
	in := PostAndCommentsPushNotification{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PostAndCommentsPushNotificationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &PostAndCommentsPushNotificationORM{}, &PostAndCommentsPushNotification{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PostAndCommentsPushNotificationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PostAndCommentsPushNotificationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PostAndCommentsPushNotificationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*PostAndCommentsPushNotification{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PostAndCommentsPushNotificationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PostAndCommentsPushNotificationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PostAndCommentsPushNotificationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]PostAndCommentsPushNotificationORM) error
}

// DefaultCreateFollowingAndFollowersPushNotification executes a basic gorm create call
func DefaultCreateFollowingAndFollowersPushNotification(ctx context.Context, in *FollowingAndFollowersPushNotification, db *gorm1.DB) (*FollowingAndFollowersPushNotification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FollowingAndFollowersPushNotificationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FollowingAndFollowersPushNotificationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FollowingAndFollowersPushNotificationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FollowingAndFollowersPushNotificationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadFollowingAndFollowersPushNotification executes a basic gorm read call
func DefaultReadFollowingAndFollowersPushNotification(ctx context.Context, in *FollowingAndFollowersPushNotification, db *gorm1.DB) (*FollowingAndFollowersPushNotification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FollowingAndFollowersPushNotificationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &FollowingAndFollowersPushNotificationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FollowingAndFollowersPushNotificationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := FollowingAndFollowersPushNotificationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(FollowingAndFollowersPushNotificationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type FollowingAndFollowersPushNotificationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FollowingAndFollowersPushNotificationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FollowingAndFollowersPushNotificationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteFollowingAndFollowersPushNotification(ctx context.Context, in *FollowingAndFollowersPushNotification, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(FollowingAndFollowersPushNotificationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&FollowingAndFollowersPushNotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(FollowingAndFollowersPushNotificationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type FollowingAndFollowersPushNotificationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FollowingAndFollowersPushNotificationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteFollowingAndFollowersPushNotificationSet(ctx context.Context, in []*FollowingAndFollowersPushNotification, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&FollowingAndFollowersPushNotificationORM{})).(FollowingAndFollowersPushNotificationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&FollowingAndFollowersPushNotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&FollowingAndFollowersPushNotificationORM{})).(FollowingAndFollowersPushNotificationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type FollowingAndFollowersPushNotificationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*FollowingAndFollowersPushNotification, *gorm1.DB) (*gorm1.DB, error)
}
type FollowingAndFollowersPushNotificationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*FollowingAndFollowersPushNotification, *gorm1.DB) error
}

// DefaultStrictUpdateFollowingAndFollowersPushNotification clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateFollowingAndFollowersPushNotification(ctx context.Context, in *FollowingAndFollowersPushNotification, db *gorm1.DB) (*FollowingAndFollowersPushNotification, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateFollowingAndFollowersPushNotification")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &FollowingAndFollowersPushNotificationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(FollowingAndFollowersPushNotificationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(FollowingAndFollowersPushNotificationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FollowingAndFollowersPushNotificationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type FollowingAndFollowersPushNotificationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FollowingAndFollowersPushNotificationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FollowingAndFollowersPushNotificationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchFollowingAndFollowersPushNotification executes a basic gorm update call with patch behavior
func DefaultPatchFollowingAndFollowersPushNotification(ctx context.Context, in *FollowingAndFollowersPushNotification, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*FollowingAndFollowersPushNotification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj FollowingAndFollowersPushNotification
	var err error
	if hook, ok := interface{}(&pbObj).(FollowingAndFollowersPushNotificationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadFollowingAndFollowersPushNotification(ctx, &FollowingAndFollowersPushNotification{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(FollowingAndFollowersPushNotificationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskFollowingAndFollowersPushNotification(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(FollowingAndFollowersPushNotificationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateFollowingAndFollowersPushNotification(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(FollowingAndFollowersPushNotificationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type FollowingAndFollowersPushNotificationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *FollowingAndFollowersPushNotification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FollowingAndFollowersPushNotificationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *FollowingAndFollowersPushNotification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FollowingAndFollowersPushNotificationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *FollowingAndFollowersPushNotification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type FollowingAndFollowersPushNotificationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *FollowingAndFollowersPushNotification, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetFollowingAndFollowersPushNotification executes a bulk gorm update call with patch behavior
func DefaultPatchSetFollowingAndFollowersPushNotification(ctx context.Context, objects []*FollowingAndFollowersPushNotification, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*FollowingAndFollowersPushNotification, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*FollowingAndFollowersPushNotification, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchFollowingAndFollowersPushNotification(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskFollowingAndFollowersPushNotification patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFollowingAndFollowersPushNotification(ctx context.Context, patchee *FollowingAndFollowersPushNotification, patcher *FollowingAndFollowersPushNotification, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*FollowingAndFollowersPushNotification, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedFollowerRequests bool
	var updatedAcceptedFollowerRequests bool
	var updatedMentionsInBio bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if !updatedFollowerRequests && strings.HasPrefix(f, prefix+"FollowerRequests.") {
			if patcher.FollowerRequests == nil {
				patchee.FollowerRequests = nil
				continue
			}
			if patchee.FollowerRequests == nil {
				patchee.FollowerRequests = &PushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"FollowerRequests."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.FollowerRequests, patchee.FollowerRequests, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"FollowerRequests" {
			updatedFollowerRequests = true
			patchee.FollowerRequests = patcher.FollowerRequests
			continue
		}
		if !updatedAcceptedFollowerRequests && strings.HasPrefix(f, prefix+"AcceptedFollowerRequests.") {
			if patcher.AcceptedFollowerRequests == nil {
				patchee.AcceptedFollowerRequests = nil
				continue
			}
			if patchee.AcceptedFollowerRequests == nil {
				patchee.AcceptedFollowerRequests = &PushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"AcceptedFollowerRequests."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.AcceptedFollowerRequests, patchee.AcceptedFollowerRequests, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"AcceptedFollowerRequests" {
			updatedAcceptedFollowerRequests = true
			patchee.AcceptedFollowerRequests = patcher.AcceptedFollowerRequests
			continue
		}
		if !updatedMentionsInBio && strings.HasPrefix(f, prefix+"MentionsInBio.") {
			if patcher.MentionsInBio == nil {
				patchee.MentionsInBio = nil
				continue
			}
			if patchee.MentionsInBio == nil {
				patchee.MentionsInBio = &TieredPushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"MentionsInBio."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.MentionsInBio, patchee.MentionsInBio, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"MentionsInBio" {
			updatedMentionsInBio = true
			patchee.MentionsInBio = patcher.MentionsInBio
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFollowingAndFollowersPushNotification executes a gorm list call
func DefaultListFollowingAndFollowersPushNotification(ctx context.Context, db *gorm1.DB) ([]*FollowingAndFollowersPushNotification, error) {
	in := FollowingAndFollowersPushNotification{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FollowingAndFollowersPushNotificationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &FollowingAndFollowersPushNotificationORM{}, &FollowingAndFollowersPushNotification{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FollowingAndFollowersPushNotificationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []FollowingAndFollowersPushNotificationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FollowingAndFollowersPushNotificationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FollowingAndFollowersPushNotification{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FollowingAndFollowersPushNotificationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FollowingAndFollowersPushNotificationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type FollowingAndFollowersPushNotificationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]FollowingAndFollowersPushNotificationORM) error
}

// DefaultCreateDirectMessagesPushNotification executes a basic gorm create call
func DefaultCreateDirectMessagesPushNotification(ctx context.Context, in *DirectMessagesPushNotification, db *gorm1.DB) (*DirectMessagesPushNotification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DirectMessagesPushNotificationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DirectMessagesPushNotificationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DirectMessagesPushNotificationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DirectMessagesPushNotificationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadDirectMessagesPushNotification executes a basic gorm read call
func DefaultReadDirectMessagesPushNotification(ctx context.Context, in *DirectMessagesPushNotification, db *gorm1.DB) (*DirectMessagesPushNotification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DirectMessagesPushNotificationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &DirectMessagesPushNotificationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DirectMessagesPushNotificationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DirectMessagesPushNotificationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DirectMessagesPushNotificationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DirectMessagesPushNotificationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DirectMessagesPushNotificationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DirectMessagesPushNotificationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteDirectMessagesPushNotification(ctx context.Context, in *DirectMessagesPushNotification, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DirectMessagesPushNotificationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DirectMessagesPushNotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DirectMessagesPushNotificationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DirectMessagesPushNotificationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DirectMessagesPushNotificationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteDirectMessagesPushNotificationSet(ctx context.Context, in []*DirectMessagesPushNotification, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&DirectMessagesPushNotificationORM{})).(DirectMessagesPushNotificationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&DirectMessagesPushNotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&DirectMessagesPushNotificationORM{})).(DirectMessagesPushNotificationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type DirectMessagesPushNotificationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*DirectMessagesPushNotification, *gorm1.DB) (*gorm1.DB, error)
}
type DirectMessagesPushNotificationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*DirectMessagesPushNotification, *gorm1.DB) error
}

// DefaultStrictUpdateDirectMessagesPushNotification clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateDirectMessagesPushNotification(ctx context.Context, in *DirectMessagesPushNotification, db *gorm1.DB) (*DirectMessagesPushNotification, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateDirectMessagesPushNotification")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &DirectMessagesPushNotificationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(DirectMessagesPushNotificationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DirectMessagesPushNotificationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DirectMessagesPushNotificationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type DirectMessagesPushNotificationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DirectMessagesPushNotificationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DirectMessagesPushNotificationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchDirectMessagesPushNotification executes a basic gorm update call with patch behavior
func DefaultPatchDirectMessagesPushNotification(ctx context.Context, in *DirectMessagesPushNotification, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*DirectMessagesPushNotification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj DirectMessagesPushNotification
	var err error
	if hook, ok := interface{}(&pbObj).(DirectMessagesPushNotificationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadDirectMessagesPushNotification(ctx, &DirectMessagesPushNotification{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(DirectMessagesPushNotificationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskDirectMessagesPushNotification(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(DirectMessagesPushNotificationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateDirectMessagesPushNotification(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(DirectMessagesPushNotificationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type DirectMessagesPushNotificationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *DirectMessagesPushNotification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type DirectMessagesPushNotificationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *DirectMessagesPushNotification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type DirectMessagesPushNotificationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *DirectMessagesPushNotification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type DirectMessagesPushNotificationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *DirectMessagesPushNotification, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetDirectMessagesPushNotification executes a bulk gorm update call with patch behavior
func DefaultPatchSetDirectMessagesPushNotification(ctx context.Context, objects []*DirectMessagesPushNotification, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*DirectMessagesPushNotification, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*DirectMessagesPushNotification, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchDirectMessagesPushNotification(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskDirectMessagesPushNotification patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDirectMessagesPushNotification(ctx context.Context, patchee *DirectMessagesPushNotification, patcher *DirectMessagesPushNotification, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*DirectMessagesPushNotification, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedMessageRequests bool
	var updatedMessage bool
	var updatedGroupRequests bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if !updatedMessageRequests && strings.HasPrefix(f, prefix+"MessageRequests.") {
			if patcher.MessageRequests == nil {
				patchee.MessageRequests = nil
				continue
			}
			if patchee.MessageRequests == nil {
				patchee.MessageRequests = &PushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"MessageRequests."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.MessageRequests, patchee.MessageRequests, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"MessageRequests" {
			updatedMessageRequests = true
			patchee.MessageRequests = patcher.MessageRequests
			continue
		}
		if !updatedMessage && strings.HasPrefix(f, prefix+"Message.") {
			if patcher.Message == nil {
				patchee.Message = nil
				continue
			}
			if patchee.Message == nil {
				patchee.Message = &PushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Message."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.Message, patchee.Message, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Message" {
			updatedMessage = true
			patchee.Message = patcher.Message
			continue
		}
		if !updatedGroupRequests && strings.HasPrefix(f, prefix+"GroupRequests.") {
			if patcher.GroupRequests == nil {
				patchee.GroupRequests = nil
				continue
			}
			if patchee.GroupRequests == nil {
				patchee.GroupRequests = &PushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"GroupRequests."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.GroupRequests, patchee.GroupRequests, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"GroupRequests" {
			updatedGroupRequests = true
			patchee.GroupRequests = patcher.GroupRequests
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDirectMessagesPushNotification executes a gorm list call
func DefaultListDirectMessagesPushNotification(ctx context.Context, db *gorm1.DB) ([]*DirectMessagesPushNotification, error) {
	in := DirectMessagesPushNotification{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DirectMessagesPushNotificationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &DirectMessagesPushNotificationORM{}, &DirectMessagesPushNotification{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DirectMessagesPushNotificationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []DirectMessagesPushNotificationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DirectMessagesPushNotificationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*DirectMessagesPushNotification{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DirectMessagesPushNotificationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DirectMessagesPushNotificationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DirectMessagesPushNotificationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]DirectMessagesPushNotificationORM) error
}

// DefaultCreateEmailAndSmsPushNotification executes a basic gorm create call
func DefaultCreateEmailAndSmsPushNotification(ctx context.Context, in *EmailAndSmsPushNotification, db *gorm1.DB) (*EmailAndSmsPushNotification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailAndSmsPushNotificationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailAndSmsPushNotificationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EmailAndSmsPushNotificationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailAndSmsPushNotificationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadEmailAndSmsPushNotification executes a basic gorm read call
func DefaultReadEmailAndSmsPushNotification(ctx context.Context, in *EmailAndSmsPushNotification, db *gorm1.DB) (*EmailAndSmsPushNotification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmailAndSmsPushNotificationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &EmailAndSmsPushNotificationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailAndSmsPushNotificationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EmailAndSmsPushNotificationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EmailAndSmsPushNotificationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EmailAndSmsPushNotificationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailAndSmsPushNotificationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailAndSmsPushNotificationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteEmailAndSmsPushNotification(ctx context.Context, in *EmailAndSmsPushNotification, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmailAndSmsPushNotificationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EmailAndSmsPushNotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EmailAndSmsPushNotificationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EmailAndSmsPushNotificationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailAndSmsPushNotificationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteEmailAndSmsPushNotificationSet(ctx context.Context, in []*EmailAndSmsPushNotification, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EmailAndSmsPushNotificationORM{})).(EmailAndSmsPushNotificationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EmailAndSmsPushNotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EmailAndSmsPushNotificationORM{})).(EmailAndSmsPushNotificationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EmailAndSmsPushNotificationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*EmailAndSmsPushNotification, *gorm1.DB) (*gorm1.DB, error)
}
type EmailAndSmsPushNotificationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*EmailAndSmsPushNotification, *gorm1.DB) error
}

// DefaultStrictUpdateEmailAndSmsPushNotification clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEmailAndSmsPushNotification(ctx context.Context, in *EmailAndSmsPushNotification, db *gorm1.DB) (*EmailAndSmsPushNotification, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEmailAndSmsPushNotification")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EmailAndSmsPushNotificationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EmailAndSmsPushNotificationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EmailAndSmsPushNotificationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailAndSmsPushNotificationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EmailAndSmsPushNotificationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailAndSmsPushNotificationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailAndSmsPushNotificationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchEmailAndSmsPushNotification executes a basic gorm update call with patch behavior
func DefaultPatchEmailAndSmsPushNotification(ctx context.Context, in *EmailAndSmsPushNotification, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*EmailAndSmsPushNotification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj EmailAndSmsPushNotification
	var err error
	if hook, ok := interface{}(&pbObj).(EmailAndSmsPushNotificationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEmailAndSmsPushNotification(ctx, &EmailAndSmsPushNotification{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EmailAndSmsPushNotificationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEmailAndSmsPushNotification(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EmailAndSmsPushNotificationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEmailAndSmsPushNotification(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EmailAndSmsPushNotificationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EmailAndSmsPushNotificationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *EmailAndSmsPushNotification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EmailAndSmsPushNotificationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *EmailAndSmsPushNotification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EmailAndSmsPushNotificationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *EmailAndSmsPushNotification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EmailAndSmsPushNotificationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *EmailAndSmsPushNotification, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetEmailAndSmsPushNotification executes a bulk gorm update call with patch behavior
func DefaultPatchSetEmailAndSmsPushNotification(ctx context.Context, objects []*EmailAndSmsPushNotification, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*EmailAndSmsPushNotification, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*EmailAndSmsPushNotification, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEmailAndSmsPushNotification(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEmailAndSmsPushNotification patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEmailAndSmsPushNotification(ctx context.Context, patchee *EmailAndSmsPushNotification, patcher *EmailAndSmsPushNotification, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*EmailAndSmsPushNotification, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedFeedbackEmail bool
	var updatedReminderEmails bool
	var updatedProductEmails bool
	var updatedNewsEmails bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DeletedAt" {
			patchee.DeletedAt = patcher.DeletedAt
			continue
		}
		if !updatedFeedbackEmail && strings.HasPrefix(f, prefix+"FeedbackEmail.") {
			if patcher.FeedbackEmail == nil {
				patchee.FeedbackEmail = nil
				continue
			}
			if patchee.FeedbackEmail == nil {
				patchee.FeedbackEmail = &PushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"FeedbackEmail."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.FeedbackEmail, patchee.FeedbackEmail, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"FeedbackEmail" {
			updatedFeedbackEmail = true
			patchee.FeedbackEmail = patcher.FeedbackEmail
			continue
		}
		if !updatedReminderEmails && strings.HasPrefix(f, prefix+"ReminderEmails.") {
			if patcher.ReminderEmails == nil {
				patchee.ReminderEmails = nil
				continue
			}
			if patchee.ReminderEmails == nil {
				patchee.ReminderEmails = &PushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ReminderEmails."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.ReminderEmails, patchee.ReminderEmails, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ReminderEmails" {
			updatedReminderEmails = true
			patchee.ReminderEmails = patcher.ReminderEmails
			continue
		}
		if !updatedProductEmails && strings.HasPrefix(f, prefix+"ProductEmails.") {
			if patcher.ProductEmails == nil {
				patchee.ProductEmails = nil
				continue
			}
			if patchee.ProductEmails == nil {
				patchee.ProductEmails = &PushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ProductEmails."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.ProductEmails, patchee.ProductEmails, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ProductEmails" {
			updatedProductEmails = true
			patchee.ProductEmails = patcher.ProductEmails
			continue
		}
		if !updatedNewsEmails && strings.HasPrefix(f, prefix+"NewsEmails.") {
			if patcher.NewsEmails == nil {
				patchee.NewsEmails = nil
				continue
			}
			if patchee.NewsEmails == nil {
				patchee.NewsEmails = &PushNotificationSetting{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"NewsEmails."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.NewsEmails, patchee.NewsEmails, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"NewsEmails" {
			updatedNewsEmails = true
			patchee.NewsEmails = patcher.NewsEmails
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEmailAndSmsPushNotification executes a gorm list call
func DefaultListEmailAndSmsPushNotification(ctx context.Context, db *gorm1.DB) ([]*EmailAndSmsPushNotification, error) {
	in := EmailAndSmsPushNotification{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailAndSmsPushNotificationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &EmailAndSmsPushNotificationORM{}, &EmailAndSmsPushNotification{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailAndSmsPushNotificationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EmailAndSmsPushNotificationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailAndSmsPushNotificationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*EmailAndSmsPushNotification{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EmailAndSmsPushNotificationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailAndSmsPushNotificationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmailAndSmsPushNotificationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]EmailAndSmsPushNotificationORM) error
}
