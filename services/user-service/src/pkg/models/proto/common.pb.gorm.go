// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/common.proto

/*
Package user is a generated protocol buffer package.

It is generated from these files:
	proto/common.proto
	proto/tables.proto
	proto/user_service.proto

It has these top-level messages:
	Address
	Education
	Interests
	Topic
	Industry
	Subscriptions
	SkillSet
	Skill
	Contact
	SocialMedia
	Details
	Experience
	Investment
	Settings
	LoginActivity
	Payments
	Card
	Pin
	Privacy
	Notification
	PostAndCommentsPushNotificationSettings
	FollowingAndFollowersPushNotificationSettings
	DirectMessagesPushNotificationSettings
	EmailAndSmsPushNotificationSettings
	TieredPushNotificationSetting
	PushNotificationSetting
	User
	Profile
	Group
	Team
	InvestorFundingDetails
	StartupFundingDetails
	Funding
	GetUsersSearchRequest
	Uint32UserTypeRequest
	Uint32TeamTypeRequest
	Uint32GroupTypeRequest
	StringUserTypeRequest
	StringTeamTypeRequest
	StringGroupTypeRequest
	UserResponse
	UserRequest
	TeamResponse
	TeamRequest
	GroupResponse
	GroupRequest
	UpdateOrCreateEntityResponse
*/
package user

import context "context"
import fmt "fmt"
import strings "strings"

import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"

import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type AddressORM struct {
	AddressProfileId       *int32
	BuildingNumber         string
	City                   string
	Country                string
	Id                     int32 `gorm:"type:integer;primary_key"`
	Latitude               int32
	LoginActivityId        *int32
	Longitude              int32
	PlacesLivedInProfileId *int32
	State                  string
	Street                 string
	TeamId                 *int32
	ZipCode                string
}

// TableName overrides the default tablename generated by GORM
func (AddressORM) TableName() string {
	return "addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Address) ToORM(ctx context.Context) (AddressORM, error) {
	to := AddressORM{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Longitude = m.Longitude
	to.Latitude = m.Latitude
	to.City = m.City
	to.State = m.State
	to.Country = m.Country
	to.ZipCode = m.ZipCode
	to.Street = m.Street
	to.BuildingNumber = m.BuildingNumber
	if posthook, ok := interface{}(m).(AddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AddressORM) ToPB(ctx context.Context) (Address, error) {
	to := Address{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Longitude = m.Longitude
	to.Latitude = m.Latitude
	to.City = m.City
	to.State = m.State
	to.Country = m.Country
	to.ZipCode = m.ZipCode
	to.Street = m.Street
	to.BuildingNumber = m.BuildingNumber
	if posthook, ok := interface{}(m).(AddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Address the arg will be the target, the caller the one being converted from

// AddressBeforeToORM called before default ToORM code
type AddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *AddressORM) error
}

// AddressAfterToORM called after default ToORM code
type AddressWithAfterToORM interface {
	AfterToORM(context.Context, *AddressORM) error
}

// AddressBeforeToPB called before default ToPB code
type AddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *Address) error
}

// AddressAfterToPB called after default ToPB code
type AddressWithAfterToPB interface {
	AfterToPB(context.Context, *Address) error
}

type EducationORM struct {
	DegreeEarned    string
	End             string
	Graduated       bool
	Id              int32 `gorm:"type:integer;primary_key"`
	InstitutionName string
	Major           string
	Minor           string
	ProfileId       *int32
	Start           string
}

// TableName overrides the default tablename generated by GORM
func (EducationORM) TableName() string {
	return "educations"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Education) ToORM(ctx context.Context) (EducationORM, error) {
	to := EducationORM{}
	var err error
	if prehook, ok := interface{}(m).(EducationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.InstitutionName = m.InstitutionName
	to.DegreeEarned = m.DegreeEarned
	to.Graduated = m.Graduated
	to.Major = m.Major
	to.Minor = m.Minor
	to.Start = m.Start
	to.End = m.End
	if posthook, ok := interface{}(m).(EducationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EducationORM) ToPB(ctx context.Context) (Education, error) {
	to := Education{}
	var err error
	if prehook, ok := interface{}(m).(EducationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.InstitutionName = m.InstitutionName
	to.DegreeEarned = m.DegreeEarned
	to.Graduated = m.Graduated
	to.Major = m.Major
	to.Minor = m.Minor
	to.Start = m.Start
	to.End = m.End
	if posthook, ok := interface{}(m).(EducationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Education the arg will be the target, the caller the one being converted from

// EducationBeforeToORM called before default ToORM code
type EducationWithBeforeToORM interface {
	BeforeToORM(context.Context, *EducationORM) error
}

// EducationAfterToORM called after default ToORM code
type EducationWithAfterToORM interface {
	AfterToORM(context.Context, *EducationORM) error
}

// EducationBeforeToPB called before default ToPB code
type EducationWithBeforeToPB interface {
	BeforeToPB(context.Context, *Education) error
}

// EducationAfterToPB called after default ToPB code
type EducationWithAfterToPB interface {
	AfterToPB(context.Context, *Education) error
}

type InterestsORM struct {
	Id int32 `gorm:"type:integer;primary_key"`
}

// TableName overrides the default tablename generated by GORM
func (InterestsORM) TableName() string {
	return "interests"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Interests) ToORM(ctx context.Context) (InterestsORM, error) {
	to := InterestsORM{}
	var err error
	if prehook, ok := interface{}(m).(InterestsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	// Repeated type []*Topic is not an ORMable message type
	// Repeated type []*Industry is not an ORMable message type
	if posthook, ok := interface{}(m).(InterestsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InterestsORM) ToPB(ctx context.Context) (Interests, error) {
	to := Interests{}
	var err error
	if prehook, ok := interface{}(m).(InterestsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	// Repeated type []*Topic is not an ORMable message type
	// Repeated type []*Industry is not an ORMable message type
	if posthook, ok := interface{}(m).(InterestsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Interests the arg will be the target, the caller the one being converted from

// InterestsBeforeToORM called before default ToORM code
type InterestsWithBeforeToORM interface {
	BeforeToORM(context.Context, *InterestsORM) error
}

// InterestsAfterToORM called after default ToORM code
type InterestsWithAfterToORM interface {
	AfterToORM(context.Context, *InterestsORM) error
}

// InterestsBeforeToPB called before default ToPB code
type InterestsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Interests) error
}

// InterestsAfterToPB called after default ToPB code
type InterestsWithAfterToPB interface {
	AfterToPB(context.Context, *Interests) error
}

type SubscriptionsORM struct {
	CreatedAt              string
	Id                     int32 `gorm:"type:integer;primary_key"`
	IsSubscriptionActive   bool
	ProfileId              *int32
	SubscriptionAccessType string
	SubscriptionEndDate    string
	SubscriptionName       string
	SubscriptionStartDate  string
	SubscriptionStatus     bool
	TeamId                 *int32
	UpdatedtAt             string
}

// TableName overrides the default tablename generated by GORM
func (SubscriptionsORM) TableName() string {
	return "subscriptions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Subscriptions) ToORM(ctx context.Context) (SubscriptionsORM, error) {
	to := SubscriptionsORM{}
	var err error
	if prehook, ok := interface{}(m).(SubscriptionsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.SubscriptionName = m.SubscriptionName
	to.SubscriptionStatus = m.SubscriptionStatus
	to.SubscriptionStartDate = m.SubscriptionStartDate
	to.SubscriptionEndDate = m.SubscriptionEndDate
	to.SubscriptionAccessType = m.SubscriptionAccessType
	to.IsSubscriptionActive = m.IsSubscriptionActive
	to.CreatedAt = m.CreatedAt
	to.UpdatedtAt = m.UpdatedtAt
	if posthook, ok := interface{}(m).(SubscriptionsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SubscriptionsORM) ToPB(ctx context.Context) (Subscriptions, error) {
	to := Subscriptions{}
	var err error
	if prehook, ok := interface{}(m).(SubscriptionsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.SubscriptionName = m.SubscriptionName
	to.SubscriptionStatus = m.SubscriptionStatus
	to.SubscriptionStartDate = m.SubscriptionStartDate
	to.SubscriptionEndDate = m.SubscriptionEndDate
	to.SubscriptionAccessType = m.SubscriptionAccessType
	to.IsSubscriptionActive = m.IsSubscriptionActive
	to.CreatedAt = m.CreatedAt
	to.UpdatedtAt = m.UpdatedtAt
	if posthook, ok := interface{}(m).(SubscriptionsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Subscriptions the arg will be the target, the caller the one being converted from

// SubscriptionsBeforeToORM called before default ToORM code
type SubscriptionsWithBeforeToORM interface {
	BeforeToORM(context.Context, *SubscriptionsORM) error
}

// SubscriptionsAfterToORM called after default ToORM code
type SubscriptionsWithAfterToORM interface {
	AfterToORM(context.Context, *SubscriptionsORM) error
}

// SubscriptionsBeforeToPB called before default ToPB code
type SubscriptionsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Subscriptions) error
}

// SubscriptionsAfterToPB called after default ToPB code
type SubscriptionsWithAfterToPB interface {
	AfterToPB(context.Context, *Subscriptions) error
}

type DetailsORM struct {
	CompanyType             string
	IPOStatus               string
	StartupFundingDetailsId *uint32
}

// TableName overrides the default tablename generated by GORM
func (DetailsORM) TableName() string {
	return "details"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Details) ToORM(ctx context.Context) (DetailsORM, error) {
	to := DetailsORM{}
	var err error
	if prehook, ok := interface{}(m).(DetailsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.IPOStatus = m.IPOStatus
	to.CompanyType = m.CompanyType
	if posthook, ok := interface{}(m).(DetailsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DetailsORM) ToPB(ctx context.Context) (Details, error) {
	to := Details{}
	var err error
	if prehook, ok := interface{}(m).(DetailsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.IPOStatus = m.IPOStatus
	to.CompanyType = m.CompanyType
	if posthook, ok := interface{}(m).(DetailsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Details the arg will be the target, the caller the one being converted from

// DetailsBeforeToORM called before default ToORM code
type DetailsWithBeforeToORM interface {
	BeforeToORM(context.Context, *DetailsORM) error
}

// DetailsAfterToORM called after default ToORM code
type DetailsWithAfterToORM interface {
	AfterToORM(context.Context, *DetailsORM) error
}

// DetailsBeforeToPB called before default ToPB code
type DetailsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Details) error
}

// DetailsAfterToPB called after default ToPB code
type DetailsWithAfterToPB interface {
	AfterToPB(context.Context, *Details) error
}

type ExperienceORM struct {
	CompanyName string
	EndDate     string
	ProfileId   *int32
	StartDate   string
	Title       string
}

// TableName overrides the default tablename generated by GORM
func (ExperienceORM) TableName() string {
	return "experiences"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Experience) ToORM(ctx context.Context) (ExperienceORM, error) {
	to := ExperienceORM{}
	var err error
	if prehook, ok := interface{}(m).(ExperienceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CompanyName = m.CompanyName
	to.StartDate = m.StartDate
	to.EndDate = m.EndDate
	to.Title = m.Title
	if posthook, ok := interface{}(m).(ExperienceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ExperienceORM) ToPB(ctx context.Context) (Experience, error) {
	to := Experience{}
	var err error
	if prehook, ok := interface{}(m).(ExperienceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CompanyName = m.CompanyName
	to.StartDate = m.StartDate
	to.EndDate = m.EndDate
	to.Title = m.Title
	if posthook, ok := interface{}(m).(ExperienceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Experience the arg will be the target, the caller the one being converted from

// ExperienceBeforeToORM called before default ToORM code
type ExperienceWithBeforeToORM interface {
	BeforeToORM(context.Context, *ExperienceORM) error
}

// ExperienceAfterToORM called after default ToORM code
type ExperienceWithAfterToORM interface {
	AfterToORM(context.Context, *ExperienceORM) error
}

// ExperienceBeforeToPB called before default ToPB code
type ExperienceWithBeforeToPB interface {
	BeforeToPB(context.Context, *Experience) error
}

// ExperienceAfterToPB called after default ToPB code
type ExperienceWithAfterToPB interface {
	AfterToPB(context.Context, *Experience) error
}

type InvestmentORM struct {
	CompanyName              string
	Industry                 string
	InvestorFundingDetailsId *uint32
}

// TableName overrides the default tablename generated by GORM
func (InvestmentORM) TableName() string {
	return "investments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Investment) ToORM(ctx context.Context) (InvestmentORM, error) {
	to := InvestmentORM{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CompanyName = m.CompanyName
	to.Industry = m.Industry
	if posthook, ok := interface{}(m).(InvestmentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *InvestmentORM) ToPB(ctx context.Context) (Investment, error) {
	to := Investment{}
	var err error
	if prehook, ok := interface{}(m).(InvestmentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CompanyName = m.CompanyName
	to.Industry = m.Industry
	if posthook, ok := interface{}(m).(InvestmentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Investment the arg will be the target, the caller the one being converted from

// InvestmentBeforeToORM called before default ToORM code
type InvestmentWithBeforeToORM interface {
	BeforeToORM(context.Context, *InvestmentORM) error
}

// InvestmentAfterToORM called after default ToORM code
type InvestmentWithAfterToORM interface {
	AfterToORM(context.Context, *InvestmentORM) error
}

// InvestmentBeforeToPB called before default ToPB code
type InvestmentWithBeforeToPB interface {
	BeforeToPB(context.Context, *Investment) error
}

// InvestmentAfterToPB called after default ToPB code
type InvestmentWithAfterToPB interface {
	AfterToPB(context.Context, *Investment) error
}

type SettingsORM struct {
	Activity      []*LoginActivityORM `gorm:"foreignkey:SettingsId;association_foreignkey:Id"`
	Id            int32               `gorm:"type:integer;primary_key"`
	Notifications *NotificationORM    `gorm:"foreignkey:SettingsId;association_foreignkey:Id"`
}

// TableName overrides the default tablename generated by GORM
func (SettingsORM) TableName() string {
	return "settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Settings) ToORM(ctx context.Context) (SettingsORM, error) {
	to := SettingsORM{}
	var err error
	if prehook, ok := interface{}(m).(SettingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Notifications != nil {
		tempNotifications, err := m.Notifications.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Notifications = &tempNotifications
	}
	for _, v := range m.Activity {
		if v != nil {
			if tempActivity, cErr := v.ToORM(ctx); cErr == nil {
				to.Activity = append(to.Activity, &tempActivity)
			} else {
				return to, cErr
			}
		} else {
			to.Activity = append(to.Activity, nil)
		}
	}
	if posthook, ok := interface{}(m).(SettingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SettingsORM) ToPB(ctx context.Context) (Settings, error) {
	to := Settings{}
	var err error
	if prehook, ok := interface{}(m).(SettingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Notifications != nil {
		tempNotifications, err := m.Notifications.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Notifications = &tempNotifications
	}
	for _, v := range m.Activity {
		if v != nil {
			if tempActivity, cErr := v.ToPB(ctx); cErr == nil {
				to.Activity = append(to.Activity, &tempActivity)
			} else {
				return to, cErr
			}
		} else {
			to.Activity = append(to.Activity, nil)
		}
	}
	if posthook, ok := interface{}(m).(SettingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Settings the arg will be the target, the caller the one being converted from

// SettingsBeforeToORM called before default ToORM code
type SettingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *SettingsORM) error
}

// SettingsAfterToORM called after default ToORM code
type SettingsWithAfterToORM interface {
	AfterToORM(context.Context, *SettingsORM) error
}

// SettingsBeforeToPB called before default ToPB code
type SettingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Settings) error
}

// SettingsAfterToPB called after default ToPB code
type SettingsWithAfterToPB interface {
	AfterToPB(context.Context, *Settings) error
}

type LoginActivityORM struct {
	Date       string
	Id         int32       `gorm:"type:integer;primary_key"`
	Location   *AddressORM `gorm:"foreignkey:LoginActivityId;association_foreignkey:Id"`
	SettingsId *int32
}

// TableName overrides the default tablename generated by GORM
func (LoginActivityORM) TableName() string {
	return "login_activities"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LoginActivity) ToORM(ctx context.Context) (LoginActivityORM, error) {
	to := LoginActivityORM{}
	var err error
	if prehook, ok := interface{}(m).(LoginActivityWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Location != nil {
		tempLocation, err := m.Location.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Location = &tempLocation
	}
	to.Date = m.Date
	if posthook, ok := interface{}(m).(LoginActivityWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LoginActivityORM) ToPB(ctx context.Context) (LoginActivity, error) {
	to := LoginActivity{}
	var err error
	if prehook, ok := interface{}(m).(LoginActivityWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.Location != nil {
		tempLocation, err := m.Location.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Location = &tempLocation
	}
	to.Date = m.Date
	if posthook, ok := interface{}(m).(LoginActivityWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LoginActivity the arg will be the target, the caller the one being converted from

// LoginActivityBeforeToORM called before default ToORM code
type LoginActivityWithBeforeToORM interface {
	BeforeToORM(context.Context, *LoginActivityORM) error
}

// LoginActivityAfterToORM called after default ToORM code
type LoginActivityWithAfterToORM interface {
	AfterToORM(context.Context, *LoginActivityORM) error
}

// LoginActivityBeforeToPB called before default ToPB code
type LoginActivityWithBeforeToPB interface {
	BeforeToPB(context.Context, *LoginActivity) error
}

// LoginActivityAfterToPB called after default ToPB code
type LoginActivityWithAfterToPB interface {
	AfterToPB(context.Context, *LoginActivity) error
}

type CardORM struct {
	Address      string
	CardNumber   string
	CardZipCode  string
	City         string
	FullName     string
	SecurityCode string
	State        string
	ZipCode      string
}

// TableName overrides the default tablename generated by GORM
func (CardORM) TableName() string {
	return "cards"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Card) ToORM(ctx context.Context) (CardORM, error) {
	to := CardORM{}
	var err error
	if prehook, ok := interface{}(m).(CardWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CardNumber = m.CardNumber
	to.SecurityCode = m.SecurityCode
	to.CardZipCode = m.CardZipCode
	to.FullName = m.FullName
	to.Address = m.Address
	to.City = m.City
	to.State = m.State
	to.ZipCode = m.ZipCode
	if posthook, ok := interface{}(m).(CardWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CardORM) ToPB(ctx context.Context) (Card, error) {
	to := Card{}
	var err error
	if prehook, ok := interface{}(m).(CardWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.CardNumber = m.CardNumber
	to.SecurityCode = m.SecurityCode
	to.CardZipCode = m.CardZipCode
	to.FullName = m.FullName
	to.Address = m.Address
	to.City = m.City
	to.State = m.State
	to.ZipCode = m.ZipCode
	if posthook, ok := interface{}(m).(CardWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Card the arg will be the target, the caller the one being converted from

// CardBeforeToORM called before default ToORM code
type CardWithBeforeToORM interface {
	BeforeToORM(context.Context, *CardORM) error
}

// CardAfterToORM called after default ToORM code
type CardWithAfterToORM interface {
	AfterToORM(context.Context, *CardORM) error
}

// CardBeforeToPB called before default ToPB code
type CardWithBeforeToPB interface {
	BeforeToPB(context.Context, *Card) error
}

// CardAfterToPB called after default ToPB code
type CardWithAfterToPB interface {
	AfterToPB(context.Context, *Card) error
}

type NotificationORM struct {
	Id         uint32
	PauseAll   bool
	SettingsId *int32
}

// TableName overrides the default tablename generated by GORM
func (NotificationORM) TableName() string {
	return "notifications"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Notification) ToORM(ctx context.Context) (NotificationORM, error) {
	to := NotificationORM{}
	var err error
	if prehook, ok := interface{}(m).(NotificationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PauseAll = m.PauseAll
	if posthook, ok := interface{}(m).(NotificationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *NotificationORM) ToPB(ctx context.Context) (Notification, error) {
	to := Notification{}
	var err error
	if prehook, ok := interface{}(m).(NotificationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.PauseAll = m.PauseAll
	if posthook, ok := interface{}(m).(NotificationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Notification the arg will be the target, the caller the one being converted from

// NotificationBeforeToORM called before default ToORM code
type NotificationWithBeforeToORM interface {
	BeforeToORM(context.Context, *NotificationORM) error
}

// NotificationAfterToORM called after default ToORM code
type NotificationWithAfterToORM interface {
	AfterToORM(context.Context, *NotificationORM) error
}

// NotificationBeforeToPB called before default ToPB code
type NotificationWithBeforeToPB interface {
	BeforeToPB(context.Context, *Notification) error
}

// NotificationAfterToPB called after default ToPB code
type NotificationWithAfterToPB interface {
	AfterToPB(context.Context, *Notification) error
}

// DefaultCreateAddress executes a basic gorm create call
func DefaultCreateAddress(ctx context.Context, in *Address, db *gorm1.DB) (*Address, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadAddress executes a basic gorm read call
func DefaultReadAddress(ctx context.Context, in *Address, db *gorm1.DB) (*Address, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &AddressORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteAddress(ctx context.Context, in *Address, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteAddressSet(ctx context.Context, in []*Address, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Address, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Address, *gorm1.DB) error
}

// DefaultStrictUpdateAddress clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAddress(ctx context.Context, in *Address, db *gorm1.DB) (*Address, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AddressORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchAddress executes a basic gorm update call with patch behavior
func DefaultPatchAddress(ctx context.Context, in *Address, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Address, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Address
	var err error
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAddress(ctx, &Address{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Address, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Address, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Address, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Address, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetAddress(ctx context.Context, objects []*Address, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Address, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Address, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAddress(ctx context.Context, patchee *Address, patcher *Address, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Address, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Longitude" {
			patchee.Longitude = patcher.Longitude
			continue
		}
		if f == prefix+"Latitude" {
			patchee.Latitude = patcher.Latitude
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
		if f == prefix+"ZipCode" {
			patchee.ZipCode = patcher.ZipCode
			continue
		}
		if f == prefix+"Street" {
			patchee.Street = patcher.Street
			continue
		}
		if f == prefix+"BuildingNumber" {
			patchee.BuildingNumber = patcher.BuildingNumber
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAddress executes a gorm list call
func DefaultListAddress(ctx context.Context, db *gorm1.DB) ([]*Address, error) {
	in := Address{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &AddressORM{}, &Address{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Address{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]AddressORM) error
}

// DefaultCreateEducation executes a basic gorm create call
func DefaultCreateEducation(ctx context.Context, in *Education, db *gorm1.DB) (*Education, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EducationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadEducation executes a basic gorm read call
func DefaultReadEducation(ctx context.Context, in *Education, db *gorm1.DB) (*Education, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &EducationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EducationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EducationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EducationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteEducation(ctx context.Context, in *Education, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EducationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EducationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteEducationSet(ctx context.Context, in []*Education, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EducationORM{})).(EducationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EducationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EducationORM{})).(EducationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EducationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Education, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Education, *gorm1.DB) error
}

// DefaultStrictUpdateEducation clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEducation(ctx context.Context, in *Education, db *gorm1.DB) (*Education, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEducation")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EducationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EducationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchEducation executes a basic gorm update call with patch behavior
func DefaultPatchEducation(ctx context.Context, in *Education, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Education, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Education
	var err error
	if hook, ok := interface{}(&pbObj).(EducationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEducation(ctx, &Education{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EducationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEducation(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EducationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEducation(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EducationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EducationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Education, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EducationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Education, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EducationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Education, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EducationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Education, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetEducation executes a bulk gorm update call with patch behavior
func DefaultPatchSetEducation(ctx context.Context, objects []*Education, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Education, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Education, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEducation(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEducation patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEducation(ctx context.Context, patchee *Education, patcher *Education, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Education, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"InstitutionName" {
			patchee.InstitutionName = patcher.InstitutionName
			continue
		}
		if f == prefix+"DegreeEarned" {
			patchee.DegreeEarned = patcher.DegreeEarned
			continue
		}
		if f == prefix+"Graduated" {
			patchee.Graduated = patcher.Graduated
			continue
		}
		if f == prefix+"Major" {
			patchee.Major = patcher.Major
			continue
		}
		if f == prefix+"Minor" {
			patchee.Minor = patcher.Minor
			continue
		}
		if f == prefix+"Start" {
			patchee.Start = patcher.Start
			continue
		}
		if f == prefix+"End" {
			patchee.End = patcher.End
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEducation executes a gorm list call
func DefaultListEducation(ctx context.Context, db *gorm1.DB) ([]*Education, error) {
	in := Education{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &EducationORM{}, &Education{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EducationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EducationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Education{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EducationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EducationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]EducationORM) error
}

// DefaultCreateInterests executes a basic gorm create call
func DefaultCreateInterests(ctx context.Context, in *Interests, db *gorm1.DB) (*Interests, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InterestsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InterestsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InterestsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InterestsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadInterests executes a basic gorm read call
func DefaultReadInterests(ctx context.Context, in *Interests, db *gorm1.DB) (*Interests, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InterestsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &InterestsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InterestsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := InterestsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(InterestsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type InterestsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InterestsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InterestsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteInterests(ctx context.Context, in *Interests, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(InterestsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&InterestsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(InterestsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type InterestsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InterestsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteInterestsSet(ctx context.Context, in []*Interests, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&InterestsORM{})).(InterestsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&InterestsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&InterestsORM{})).(InterestsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type InterestsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Interests, *gorm1.DB) (*gorm1.DB, error)
}
type InterestsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Interests, *gorm1.DB) error
}

// DefaultStrictUpdateInterests clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateInterests(ctx context.Context, in *Interests, db *gorm1.DB) (*Interests, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateInterests")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &InterestsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(InterestsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(InterestsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InterestsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type InterestsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InterestsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InterestsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchInterests executes a basic gorm update call with patch behavior
func DefaultPatchInterests(ctx context.Context, in *Interests, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Interests, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Interests
	var err error
	if hook, ok := interface{}(&pbObj).(InterestsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadInterests(ctx, &Interests{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(InterestsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskInterests(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(InterestsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateInterests(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(InterestsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type InterestsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Interests, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type InterestsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Interests, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type InterestsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Interests, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type InterestsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Interests, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetInterests executes a bulk gorm update call with patch behavior
func DefaultPatchSetInterests(ctx context.Context, objects []*Interests, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Interests, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Interests, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchInterests(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskInterests patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInterests(ctx context.Context, patchee *Interests, patcher *Interests, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Interests, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Topics" {
			patchee.Topics = patcher.Topics
			continue
		}
		if f == prefix+"Industry" {
			patchee.Industry = patcher.Industry
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInterests executes a gorm list call
func DefaultListInterests(ctx context.Context, db *gorm1.DB) ([]*Interests, error) {
	in := Interests{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InterestsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &InterestsORM{}, &Interests{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InterestsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []InterestsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InterestsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Interests{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InterestsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InterestsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InterestsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]InterestsORM) error
}

// DefaultCreateSubscriptions executes a basic gorm create call
func DefaultCreateSubscriptions(ctx context.Context, in *Subscriptions, db *gorm1.DB) (*Subscriptions, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SubscriptionsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadSubscriptions executes a basic gorm read call
func DefaultReadSubscriptions(ctx context.Context, in *Subscriptions, db *gorm1.DB) (*Subscriptions, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &SubscriptionsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SubscriptionsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SubscriptionsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SubscriptionsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteSubscriptions(ctx context.Context, in *Subscriptions, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SubscriptionsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SubscriptionsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteSubscriptionsSet(ctx context.Context, in []*Subscriptions, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SubscriptionsORM{})).(SubscriptionsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SubscriptionsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SubscriptionsORM{})).(SubscriptionsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SubscriptionsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Subscriptions, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Subscriptions, *gorm1.DB) error
}

// DefaultStrictUpdateSubscriptions clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSubscriptions(ctx context.Context, in *Subscriptions, db *gorm1.DB) (*Subscriptions, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSubscriptions")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SubscriptionsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SubscriptionsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchSubscriptions executes a basic gorm update call with patch behavior
func DefaultPatchSubscriptions(ctx context.Context, in *Subscriptions, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Subscriptions, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Subscriptions
	var err error
	if hook, ok := interface{}(&pbObj).(SubscriptionsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSubscriptions(ctx, &Subscriptions{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SubscriptionsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSubscriptions(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SubscriptionsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSubscriptions(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SubscriptionsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SubscriptionsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Subscriptions, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Subscriptions, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Subscriptions, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Subscriptions, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetSubscriptions executes a bulk gorm update call with patch behavior
func DefaultPatchSetSubscriptions(ctx context.Context, objects []*Subscriptions, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Subscriptions, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Subscriptions, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSubscriptions(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSubscriptions patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSubscriptions(ctx context.Context, patchee *Subscriptions, patcher *Subscriptions, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Subscriptions, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"SubscriptionName" {
			patchee.SubscriptionName = patcher.SubscriptionName
			continue
		}
		if f == prefix+"SubscriptionStatus" {
			patchee.SubscriptionStatus = patcher.SubscriptionStatus
			continue
		}
		if f == prefix+"SubscriptionStartDate" {
			patchee.SubscriptionStartDate = patcher.SubscriptionStartDate
			continue
		}
		if f == prefix+"SubscriptionEndDate" {
			patchee.SubscriptionEndDate = patcher.SubscriptionEndDate
			continue
		}
		if f == prefix+"SubscriptionAccessType" {
			patchee.SubscriptionAccessType = patcher.SubscriptionAccessType
			continue
		}
		if f == prefix+"IsSubscriptionActive" {
			patchee.IsSubscriptionActive = patcher.IsSubscriptionActive
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"UpdatedtAt" {
			patchee.UpdatedtAt = patcher.UpdatedtAt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSubscriptions executes a gorm list call
func DefaultListSubscriptions(ctx context.Context, db *gorm1.DB) ([]*Subscriptions, error) {
	in := Subscriptions{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &SubscriptionsORM{}, &Subscriptions{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SubscriptionsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Subscriptions{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SubscriptionsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SubscriptionsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]SubscriptionsORM) error
}

// DefaultCreateDetails executes a basic gorm create call
func DefaultCreateDetails(ctx context.Context, in *Details, db *gorm1.DB) (*Details, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DetailsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DetailsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DetailsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DetailsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultApplyFieldMaskDetails patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDetails(ctx context.Context, patchee *Details, patcher *Details, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Details, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"IPOStatus" {
			patchee.IPOStatus = patcher.IPOStatus
			continue
		}
		if f == prefix+"CompanyType" {
			patchee.CompanyType = patcher.CompanyType
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDetails executes a gorm list call
func DefaultListDetails(ctx context.Context, db *gorm1.DB) ([]*Details, error) {
	in := Details{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DetailsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &DetailsORM{}, &Details{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DetailsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []DetailsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DetailsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Details{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DetailsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DetailsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type DetailsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]DetailsORM) error
}

// DefaultCreateExperience executes a basic gorm create call
func DefaultCreateExperience(ctx context.Context, in *Experience, db *gorm1.DB) (*Experience, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ExperienceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultApplyFieldMaskExperience patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskExperience(ctx context.Context, patchee *Experience, patcher *Experience, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Experience, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"CompanyName" {
			patchee.CompanyName = patcher.CompanyName
			continue
		}
		if f == prefix+"StartDate" {
			patchee.StartDate = patcher.StartDate
			continue
		}
		if f == prefix+"EndDate" {
			patchee.EndDate = patcher.EndDate
			continue
		}
		if f == prefix+"Title" {
			patchee.Title = patcher.Title
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListExperience executes a gorm list call
func DefaultListExperience(ctx context.Context, db *gorm1.DB) ([]*Experience, error) {
	in := Experience{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ExperienceORM{}, &Experience{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []ExperienceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ExperienceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Experience{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ExperienceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ExperienceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ExperienceORM) error
}

// DefaultCreateInvestment executes a basic gorm create call
func DefaultCreateInvestment(ctx context.Context, in *Investment, db *gorm1.DB) (*Investment, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type InvestmentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultApplyFieldMaskInvestment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskInvestment(ctx context.Context, patchee *Investment, patcher *Investment, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Investment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"CompanyName" {
			patchee.CompanyName = patcher.CompanyName
			continue
		}
		if f == prefix+"Industry" {
			patchee.Industry = patcher.Industry
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListInvestment executes a gorm list call
func DefaultListInvestment(ctx context.Context, db *gorm1.DB) ([]*Investment, error) {
	in := Investment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &InvestmentORM{}, &Investment{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []InvestmentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(InvestmentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Investment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type InvestmentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type InvestmentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]InvestmentORM) error
}

// DefaultCreateSettings executes a basic gorm create call
func DefaultCreateSettings(ctx context.Context, in *Settings, db *gorm1.DB) (*Settings, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SettingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadSettings executes a basic gorm read call
func DefaultReadSettings(ctx context.Context, in *Settings, db *gorm1.DB) (*Settings, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &SettingsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SettingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SettingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SettingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteSettings(ctx context.Context, in *Settings, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SettingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteSettingsSet(ctx context.Context, in []*Settings, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SettingsORM{})).(SettingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SettingsORM{})).(SettingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SettingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Settings, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Settings, *gorm1.DB) error
}

// DefaultStrictUpdateSettings clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSettings(ctx context.Context, in *Settings, db *gorm1.DB) (*Settings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSettings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SettingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterActivity := LoginActivityORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterActivity.SettingsId = new(int32)
	*filterActivity.SettingsId = ormObj.Id
	if err = db.Where(filterActivity).Delete(LoginActivityORM{}).Error; err != nil {
		return nil, err
	}
	filterNotifications := NotificationORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterNotifications.SettingsId = new(int32)
	*filterNotifications.SettingsId = ormObj.Id
	if err = db.Where(filterNotifications).Delete(NotificationORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SettingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchSettings executes a basic gorm update call with patch behavior
func DefaultPatchSettings(ctx context.Context, in *Settings, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Settings, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Settings
	var err error
	if hook, ok := interface{}(&pbObj).(SettingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSettings(ctx, &Settings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SettingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSettings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SettingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSettings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SettingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SettingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Settings, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Settings, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Settings, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Settings, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetSettings executes a bulk gorm update call with patch behavior
func DefaultPatchSetSettings(ctx context.Context, objects []*Settings, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Settings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Settings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSettings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSettings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSettings(ctx context.Context, patchee *Settings, patcher *Settings, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Settings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedNotifications bool
	var updatedPrivacy bool
	var updatedPayment bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedNotifications && strings.HasPrefix(f, prefix+"Notifications.") {
			updatedNotifications = true
			if patcher.Notifications == nil {
				patchee.Notifications = nil
				continue
			}
			if patchee.Notifications == nil {
				patchee.Notifications = &Notification{}
			}
			if o, err := DefaultApplyFieldMaskNotification(ctx, patchee.Notifications, patcher.Notifications, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Notifications.", db); err != nil {
				return nil, err
			} else {
				patchee.Notifications = o
			}
			continue
		}
		if f == prefix+"Notifications" {
			updatedNotifications = true
			patchee.Notifications = patcher.Notifications
			continue
		}
		if !updatedPrivacy && strings.HasPrefix(f, prefix+"Privacy.") {
			if patcher.Privacy == nil {
				patchee.Privacy = nil
				continue
			}
			if patchee.Privacy == nil {
				patchee.Privacy = &Privacy{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Privacy."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.Privacy, patchee.Privacy, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Privacy" {
			updatedPrivacy = true
			patchee.Privacy = patcher.Privacy
			continue
		}
		if !updatedPayment && strings.HasPrefix(f, prefix+"Payment.") {
			if patcher.Payment == nil {
				patchee.Payment = nil
				continue
			}
			if patchee.Payment == nil {
				patchee.Payment = &Payments{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Payment."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.Payment, patchee.Payment, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Payment" {
			updatedPayment = true
			patchee.Payment = patcher.Payment
			continue
		}
		if f == prefix+"Activity" {
			patchee.Activity = patcher.Activity
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSettings executes a gorm list call
func DefaultListSettings(ctx context.Context, db *gorm1.DB) ([]*Settings, error) {
	in := Settings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &SettingsORM{}, &Settings{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SettingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Settings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SettingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type SettingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]SettingsORM) error
}

// DefaultCreateLoginActivity executes a basic gorm create call
func DefaultCreateLoginActivity(ctx context.Context, in *LoginActivity, db *gorm1.DB) (*LoginActivity, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LoginActivityORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadLoginActivity executes a basic gorm read call
func DefaultReadLoginActivity(ctx context.Context, in *LoginActivity, db *gorm1.DB) (*LoginActivity, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &LoginActivityORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LoginActivityORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LoginActivityORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LoginActivityORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteLoginActivity(ctx context.Context, in *LoginActivity, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LoginActivityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LoginActivityORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteLoginActivitySet(ctx context.Context, in []*LoginActivity, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []int32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LoginActivityORM{})).(LoginActivityORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LoginActivityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LoginActivityORM{})).(LoginActivityORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LoginActivityORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*LoginActivity, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*LoginActivity, *gorm1.DB) error
}

// DefaultStrictUpdateLoginActivity clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLoginActivity(ctx context.Context, in *LoginActivity, db *gorm1.DB) (*LoginActivity, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLoginActivity")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LoginActivityORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterLocation := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	filterLocation.LoginActivityId = new(int32)
	*filterLocation.LoginActivityId = ormObj.Id
	if err = db.Where(filterLocation).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LoginActivityORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchLoginActivity executes a basic gorm update call with patch behavior
func DefaultPatchLoginActivity(ctx context.Context, in *LoginActivity, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*LoginActivity, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj LoginActivity
	var err error
	if hook, ok := interface{}(&pbObj).(LoginActivityWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLoginActivity(ctx, &LoginActivity{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LoginActivityWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLoginActivity(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LoginActivityWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLoginActivity(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LoginActivityWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LoginActivityWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *LoginActivity, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *LoginActivity, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *LoginActivity, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *LoginActivity, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetLoginActivity executes a bulk gorm update call with patch behavior
func DefaultPatchSetLoginActivity(ctx context.Context, objects []*LoginActivity, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*LoginActivity, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*LoginActivity, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLoginActivity(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLoginActivity patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLoginActivity(ctx context.Context, patchee *LoginActivity, patcher *LoginActivity, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*LoginActivity, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedLocation bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedLocation && strings.HasPrefix(f, prefix+"Location.") {
			updatedLocation = true
			if patcher.Location == nil {
				patchee.Location = nil
				continue
			}
			if patchee.Location == nil {
				patchee.Location = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.Location, patcher.Location, &field_mask1.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Location.", db); err != nil {
				return nil, err
			} else {
				patchee.Location = o
			}
			continue
		}
		if f == prefix+"Location" {
			updatedLocation = true
			patchee.Location = patcher.Location
			continue
		}
		if f == prefix+"Date" {
			patchee.Date = patcher.Date
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLoginActivity executes a gorm list call
func DefaultListLoginActivity(ctx context.Context, db *gorm1.DB) ([]*LoginActivity, error) {
	in := LoginActivity{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &LoginActivityORM{}, &LoginActivity{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LoginActivityORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LoginActivityORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LoginActivity{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LoginActivityORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LoginActivityORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]LoginActivityORM) error
}

// DefaultCreateCard executes a basic gorm create call
func DefaultCreateCard(ctx context.Context, in *Card, db *gorm1.DB) (*Card, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CardORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CardORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultApplyFieldMaskCard patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCard(ctx context.Context, patchee *Card, patcher *Card, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Card, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"CardNumber" {
			patchee.CardNumber = patcher.CardNumber
			continue
		}
		if f == prefix+"SecurityCode" {
			patchee.SecurityCode = patcher.SecurityCode
			continue
		}
		if f == prefix+"CardZipCode" {
			patchee.CardZipCode = patcher.CardZipCode
			continue
		}
		if f == prefix+"FullName" {
			patchee.FullName = patcher.FullName
			continue
		}
		if f == prefix+"Address" {
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"ZipCode" {
			patchee.ZipCode = patcher.ZipCode
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCard executes a gorm list call
func DefaultListCard(ctx context.Context, db *gorm1.DB) ([]*Card, error) {
	in := Card{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &CardORM{}, &Card{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []CardORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CardORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Card{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CardORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CardORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CardORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]CardORM) error
}

// DefaultCreateNotification executes a basic gorm create call
func DefaultCreateNotification(ctx context.Context, in *Notification, db *gorm1.DB) (*Notification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type NotificationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadNotification executes a basic gorm read call
func DefaultReadNotification(ctx context.Context, in *Notification, db *gorm1.DB) (*Notification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &NotificationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := NotificationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(NotificationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type NotificationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteNotification(ctx context.Context, in *Notification, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&NotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type NotificationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteNotificationSet(ctx context.Context, in []*Notification, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&NotificationORM{})).(NotificationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&NotificationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&NotificationORM{})).(NotificationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type NotificationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Notification, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Notification, *gorm1.DB) error
}

// DefaultStrictUpdateNotification clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateNotification(ctx context.Context, in *Notification, db *gorm1.DB) (*Notification, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateNotification")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &NotificationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type NotificationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchNotification executes a basic gorm update call with patch behavior
func DefaultPatchNotification(ctx context.Context, in *Notification, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Notification, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Notification
	var err error
	if hook, ok := interface{}(&pbObj).(NotificationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadNotification(ctx, &Notification{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(NotificationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskNotification(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(NotificationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateNotification(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(NotificationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type NotificationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Notification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Notification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Notification, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Notification, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetNotification executes a bulk gorm update call with patch behavior
func DefaultPatchSetNotification(ctx context.Context, objects []*Notification, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*Notification, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Notification, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchNotification(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskNotification patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskNotification(ctx context.Context, patchee *Notification, patcher *Notification, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Notification, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedPostsAndComments bool
	var updatedFollowingAndFollowers bool
	var updatedDirectMessages bool
	var updatedEmailAndSms bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"PauseAll" {
			patchee.PauseAll = patcher.PauseAll
			continue
		}
		if !updatedPostsAndComments && strings.HasPrefix(f, prefix+"PostsAndComments.") {
			if patcher.PostsAndComments == nil {
				patchee.PostsAndComments = nil
				continue
			}
			if patchee.PostsAndComments == nil {
				patchee.PostsAndComments = &PostAndCommentsPushNotificationSettings{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"PostsAndComments."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.PostsAndComments, patchee.PostsAndComments, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"PostsAndComments" {
			updatedPostsAndComments = true
			patchee.PostsAndComments = patcher.PostsAndComments
			continue
		}
		if !updatedFollowingAndFollowers && strings.HasPrefix(f, prefix+"FollowingAndFollowers.") {
			if patcher.FollowingAndFollowers == nil {
				patchee.FollowingAndFollowers = nil
				continue
			}
			if patchee.FollowingAndFollowers == nil {
				patchee.FollowingAndFollowers = &FollowingAndFollowersPushNotificationSettings{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"FollowingAndFollowers."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.FollowingAndFollowers, patchee.FollowingAndFollowers, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"FollowingAndFollowers" {
			updatedFollowingAndFollowers = true
			patchee.FollowingAndFollowers = patcher.FollowingAndFollowers
			continue
		}
		if !updatedDirectMessages && strings.HasPrefix(f, prefix+"DirectMessages.") {
			if patcher.DirectMessages == nil {
				patchee.DirectMessages = nil
				continue
			}
			if patchee.DirectMessages == nil {
				patchee.DirectMessages = &DirectMessagesPushNotificationSettings{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"DirectMessages."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.DirectMessages, patchee.DirectMessages, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"DirectMessages" {
			updatedDirectMessages = true
			patchee.DirectMessages = patcher.DirectMessages
			continue
		}
		if !updatedEmailAndSms && strings.HasPrefix(f, prefix+"EmailAndSms.") {
			if patcher.EmailAndSms == nil {
				patchee.EmailAndSms = nil
				continue
			}
			if patchee.EmailAndSms == nil {
				patchee.EmailAndSms = &EmailAndSmsPushNotificationSettings{}
			}
			childMask := &field_mask1.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EmailAndSms."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm2.MergeWithMask(patcher.EmailAndSms, patchee.EmailAndSms, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EmailAndSms" {
			updatedEmailAndSms = true
			patchee.EmailAndSms = patcher.EmailAndSms
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListNotification executes a gorm list call
func DefaultListNotification(ctx context.Context, db *gorm1.DB) ([]*Notification, error) {
	in := Notification{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &NotificationORM{}, &Notification{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []NotificationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(NotificationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Notification{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type NotificationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type NotificationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]NotificationORM) error
}
